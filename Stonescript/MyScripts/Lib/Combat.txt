// *******************************************************
//                       Combat.txt                       
// *******************************************************


/* FILE INFO

Combat functions library
Made by MetalEagle26 (Tom Crow)

This library provides some game-related
functions to make the task of doing a
farming script easier.

- How to use:
  var c = new Combat

- Tip: If you want to use the variables here,
  put c.Init() at the top of your script.

- Use the functions that you need like this:
  ?c.useBFG() // example */


// IMPORTS

var u = import MyScripts/Lib/Utilities




// VARIABLES

// Status

var midhp
var lowhp
var hihp

// Others

var moondialMode = -1
var permapotSetup = true
var smiteScreen_Target = -1
var smiteScreen_Max = -1
var maskScreen_Target = -1
var maskScreen_Max = -1

// FUNCTIONS

func Init()
  midhp = maxhp / 2
  lowhp = maxhp / 3
  hihp = (4 * maxhp) / 5

  ?buffs.string = "berserk"
    moondialMode = 2
  :
    moondialMode = 0

  ?loc.begin
    smiteScreen = 1
  :?loc.loop
    permapotSetup = false

    burstingTimer = 0

  return


// Lost items

func canUseBFG()
  return item.GetCooldown("blade") <= 0
  ^& item.CanActivate()
// cannot be interrupted, doesn't need a cooldown check
func useBFG()
  equip blade
  activate R

  return

func isScreen_DS_Target(weaponName)
  ?weaponName = "smite" | weaponName = "bfg" | weaponName = "blade"
    return screen.i = smiteScreen_Target
  :?weaponName = "mask" | weaponName = "feeble"
    return screen.i = maskScreen_Target
  :
    >c-10,0,#red,ERROR: isScreen_DS_Target()
    ^recieved incorrect weaponName: @weaponName@
    return false
func isScreen_DS_Max(weaponName)
  ?weaponName = "smite" | weaponName = "bfg" | weaponName = "blade"
    return smiteScreen_Target = smiteScreen_Max
  :?weaponName = "mask" | weaponName = "feeble"
    return maskScreen_Target = maskScreen_Max
  :
    >c-10,0,#red,ERROR: isScreen_DS_Max()
    ^recieved incorrect weaponName: @weaponName@
    return false

func screen_DS_Change(weaponName)
  ?loc.loop & totaltime = 1 & !isScreen_Max(weaponName)
    ?weaponName = "smite" | weaponName = "bfg" |
    ^weaponName = "blade"
      smiteScreen_Target++
    :?weaponName = "mask" | weaponName = "feeble"
      maskScreen_Target++
    :
      >c-10,0,#red,ERROR: screen_DS_Change()
      ^recieved incorrect weaponName: @weaponName@

  return

/* Checks if Blade of the Fallen God
can be used in 2 screens of distance,
according to a certain screen index. */
func canUseBFG_DS()
  return canUseBFG() & isScreen_DS_Target("bfg")
/* counter to give
screen.Next()
time to slide */
var slideCount = 0
func useBFG_DS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBFG()
      screen.ResetOffset()
      return


func canUseSkeletonArm()
  return item.GetCooldown("skeleton_arm") <= 0
  ^& item.CanActivate()
  ^& 3 < foe.distance & foe.distance < 9
func useSkeletonArm()
  equip arm
  activate R

  return


func canUseCultistMask()
  return item.GetCooldown("mask") <= 0
  ^& item.CanActivate()
func useCultistMask()
  equipL triskelion
  equipR mask
  activate R

  return

func canUseCultistMask_DS()
  return canUseCultistMask() &
  ^isScreen_DS_Target("mask")
func useCultistMask_DS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useCultistMask()
      screen.ResetOffset()
      return


func canUseFireTalisman()
  return
  ^item.GetCooldown("fire_talisman") <= 0 & // if it's not on cooldown
  ^item.CanActivate() & // if you can use the ability
  ^summon.GetId() ! "cinderwisp" | // if it's not summoned already
  ^(item.left = "fire_talisman" & item.left.state = 2) | // if it's equipped in the left hand
  ^(item.right = "fire_talisman" & item.right.state = 2) // or in the right hand
func useFireTalisman(hand)
  ?hand = "l" | hand = "left"
    equipL fire_talisman
    activate L
  :?hand = "r" | hand = "right"
    equipR fire_talisman
    activate R

  return

/* Same as canUseFireTalisman, But now we check if it is summoned.*/
func canHideFireTalisman()
  return
  ^item.GetCooldown("fire_talisman") &
  ^item.CanActivate() &
  ^summon.GetId() = "cinderwisp" |
  ^(item.left = "fire_talisman" & item.left.state = 2) |
  ^(item.right = "fire_talisman" & item.right.state = 2)

/* Checks if the
cinderwisp's "devour"
ability can be used. */
func canUseCinderwisp()
  return
  ^item.GetCooldown("cinderwisp") <= 0 &
  ^item.CanActivate() &
  ^summon.GetId() = "cinderwisp"
func useCinderwisp()
  activate cinderwisp
  return

/* Checks if the cinderwisp's "devour" ability
damage will kill the foe.

nIgnitions: amount of ignition debuffs currently
              applied to the foe.
cindDmg: damage dealt by cinderwisp for each ignition.
margin: number representing a health margin to add
          to the remaining foe's health. This is
          necessary because the ability has a cast time
          that will alter the estimations done here.
          Send 0 if you don't want to use a margin. */
func canKillCinderwisp(nIgnitions, cindDmg, margin)
  return foe.hp + foe.armor <= (nIgnitions * cindDmg) + margin


func canUseAetherTalisman()
  return
  ^item.GetCooldown("aether_talisman") <= 0 &
  ^item.CanActivate() &
  ^summon.GetId() ! "voidweaver" |
  ^(item.left = "aether_talisman" & item.left.state = 2) |
  ^(item.right = "aether_talisman" & item.right.state = 2)
func useAetherTalisman(hand)
  ?hand = "l" | hand = "left"
    equipL aether_talisman
    activate L
  :?hand = "r" | hand = "right"
    equipR aether_talisman
    activate R

  return

/* Same as canUseAetherTalisman,
But now we check if it
is summoned.*/
func canHideAetherTalisman()
  return
  ^item.GetCooldown("aether_talisman") &
  ^item.CanActivate() &
  ^summon.GetId() = "voidweaver" |
  ^(item.left = "aether_talisman" & item.left.state = 2) |
  ^(item.right = "aether_talisman" & item.right.state = 2)


/* Checks if the voidweaver's "devour" ability can be used. */
func canUseVoidweaver()
  return
  ^item.GetCooldown("voidweaver") <= 0 &
  ^item.CanActivate() &
  ^summon.GetId() = "voidweaver" &
  ^foe ! "boss" & // bosses are immune to unmake
  ^encounter.eliteMod ! "tenacious" & // tenacious can't be debuffed
  ^encounter.eliteMod ! "monarch" // monarch foes can't be unmade
func useVoidweaver()
  activate voidweaver
  return


/* Checks if the bashing shield's ability can be used. */
func canUseBashingShield()
  return
  ^item.GetCooldown("bash") <= 0 &
  ^item.CanActivate() &
  ^u.dash_range_min <= foe.distance &
  ^foe.distance <= u.dash_range_max &
  ^!ai.idle


// Special Weapons

func canUseHeavyHammer()
  return item.GetCooldown("heavy_hammer") <= 0 &
  ^item.CanActivate() &
  ^foe.distance <= getRange("heavy hammer ability") |
  ^(item.right = "heavy hammer" &
  ^item.right.state = 2)
func useHeavyHammer(weaponName)
  equip @weaponName@
  activate R

  return

func canUseBardiche()
  return item.GetCooldown("bardiche") <= 0 &
  ^item.CanActivate() &
  ^foe.distance <= getRange("bardiche ability") |
  ^(item.right = "bardiche" &
  ^item.right.state = 2)
func useBardiche(weaponName)
  equip @weaponName@
  activate R

  return


/* Checks if the
dashing shield's
ability can be used. */
func canUseDashingShield()
  return
  ^item.GetCooldown("dash") <= 0 &
  ^item.CanActivate() &
  ^u.dash_range_min <= foe.distance &
  ^foe.distance <= u.dash_range_max &
  ^!ai.idle

func canUseQuarterstaff()
  return
  ^item.GetCooldown("quarterstaff") <= 0 &
  ^item.CanActivate() |
  ^(item.right = "quarterstaff"
  ^& item.right.state = 2)
func useQuarterstaff(weaponName)
  equip @weaponName@
  activate R

  return


func canUseMindstone()
  return item.GetCooldown("mind") <= 0 &
  ^item.CanActivate()


/* Checks if a certain hidden wand can be used.
weaponName: the special name or the element of
            the wand.
**********************************************
****** WAND NAMES MUST BE ALL LOWERCASE ******
**********************************************
Examples: "gravity", "fire". */
func canUseWandHidden(weaponName)
  var internalName
  var requiredArmor
  var isOk = true // only set to false if weaponName is incorrect

  ?weaponName = "gravity" | weaponName = "stone"
    internalName = "wand_stone"
    requiredArmor = u.wandStoneArmor
  :?weaponName = "plague" | weaponName = "poison"
    internalName = "wand_poison"
    requiredArmor = u.wandPoisonArmor
  :?weaponName = "reset" | weaponName = "vigor"
    internalName = "wand_vigor"
    requiredArmor = u.wandVigorArmor
  :?weaponName = "calamity" | weaponName = "aether"
    internalName = "wand_aether"
    requiredArmor = u.wandArmor
  :?weaponName = "explosive" | weaponName = "fire"
    internalName = "wand_fire"
    requiredArmor = u.wandFireArmor
  :?weaponName = "frost" | weaponName = "ice"
    internalName = "wand_ice"
    requiredArmor = u.wandIceArmor
  :
    isOk = false
  
  ?isOk
    return item.CanActivate() &
    ^item.GetCooldown(internalName) <= 0 &
    ^armor >= requiredArmor

  :
    >c-10,0,#red,ERROR: canUseWandHidden()
    ^recieved incorrect weaponName: @weaponName@
    return false

/* Uses a certain hidden wand.
weaponName: the special name or the element of
            the wand.
**********************************************
****** WAND NAMES MUST BE ALL LOWERCASE ******
**********************************************
Examples: "gravity", "fire". */
func useWandHidden(weapon, weaponName, hand)
  ?weaponName = "gravity" | weaponName = "stone" |
  ^weaponName = "plague" | weaponName = "poison" |
  ^weaponName = "reset" | weaponName = "vigor" |
  ^weaponName = "calamity" | weaponName = "aether" |
  ^weaponName = "explosive" | weaponName = "fire" |
  ^weaponName = "frost" | weaponName = "ice"
    ?hand = "l" | hand = "left"
      equipL @weapon@
      activate L
    :?hand = "r" | hand = "right"
      equipR @weapon@
      activate R

  :
    >c-10,0,#red,ERROR: useWandHidden()
    ^recieved incorrect weaponName: @weaponName@

  return


/* Checks if a certain hidden staff can be used.
weaponName: the special name or the element of
            the staff.
**********************************************
****** STAFF NAMES MUST BE ALL LOWERCASE ******
**********************************************
Examples: "gravity", "fire". */
func canUseStaffHidden(weaponName)
  var internalName
  var requiredArmor
  var isOk = true // only set to false if weaponName is incorrect

  ?weaponName = "acrobatic" | weaponName = "stone"
    internalName = "staff_stone"
    requiredArmor = u.staffStoneArmor
  :?weaponName = "berserker" | weaponName = "poison"
    internalName = "staff_poison"
    requiredArmor = u.staffPoisonArmor
  :?weaponName = "prevention" | weaponName = "vigor"
    internalName = "staff_vigor"
    requiredArmor = u.staffVigorArmor
  :?weaponName = "grasping" | weaponName = "aether"
    internalName = "staff_aether"
    requiredArmor = u.staffAetherArmor
  :?weaponName = "infernal" | weaponName = "fire"
    internalName = "staff_fire"
    requiredArmor = u.staffFireArmor
  :?weaponName = "eternity" | weaponName = "ice"
    internalName = "staff_ice"
    requiredArmor = u.staffIceArmor
  
  :
    isOk = false

  ?isOk
    return item.CanActivate() &
    ^item.GetCooldown(internalName) <= 0 &
    ^armor >= requiredArmor
  :
    >c-10,0,#red,ERROR: canUseStaffHidden()
    ^recieved incorrect weaponName: @weaponName@

    return false

/* Uses a certain hidden staff.
weaponName: the special name or the element of
            the staff.
**********************************************
****** STAFF NAMES MUST BE ALL LOWERCASE ******
**********************************************
Examples: "gravity", "fire". */
func useStaffHidden(weapon, weaponName)
  ?weaponName = "acrobatic" | weaponName = "stone" |
  ^weaponName = "berserker" | weaponName = "poison" |
  ^weaponName = "prevention" | weaponName = "vigor" |
  ^weaponName = "grasping" | weaponName = "aether" |
  ^weaponName = "infernal" | weaponName = "fire" |
  ^weaponName = "eternity" | weaponName = "ice"
    equip @weapon@
    activate R

  :
    >c-10,0,#red,ERROR: useStaffHidden()
    ^recieved incorrect weaponName: @weaponName@

  return




// Tools

func canUseHatchet()
  return item.GetCooldown("hatchet") <= 0
  ^& item.CanActivate()
  ^& harvest.distance < 5
  ^& item.right = "hatchet"
func useHatchet()
  activate R
  return


// Potions

func canUsePotion()
  return
  ^item.CanActivate() &
  ^item.potion ! "empty"

/* Checks if a healing type potion
can be used.
These potions are considered as healing:
  - healing
  - defensive
  - vampiric */
func canUsePotionHeal()
  ?canUsePotion()
    ?item.potion = "healing"
      return hp + armor <= foe.damage

    :?item.potion = "vampiric"
      return hp < lowhp

    :?item.potion = "defensive"
      return hp <= midhp
    
    :
      return false
  :
    return false
/* Determines if a damage buff potion
is brewed. Generally used for bosses.
These potions are considered as damaging:
  - berserk
  - lucky */
func canUsePotionDmg()
  ?canUsePotion()
    return
    ^item.potion = "berserk" |
    ^item.potion = "lucky"
  :
    return false
/* Determines if a special potion
can be activated, given a special
condition that's different for each potion type.
Valid potion types and conditions:
  - cleansing | min. no. of debuffs to cleanse
  - strength | min. amount of foe's armor
  - lightning, | ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  - experience | min. no. of foes to activate
  - invisibility | NONE (will activate if foe = boss)
    + (send true as condition for this type) */
func canUsePotionSpecial(type,cond)
  ?canUsePotion()

    ?item.potion = type
      ?item.potion = "cleansing"
        return hp < midhp &
        ^debuffs.count >= cond
        // ^^^ = no. of debuffs to cleanse
    
      :?item.potion = "strength"
        return foe.armor & foe.armor > cond

      :?item.potion = "lightning"
      ^|item.potion = "experience"
        return foe.count >= cond

      :?item.potion = "invisibility"
        return foe = boss

      :
        >c-10,0,#red,
        ^func canUsePotionSpecial() - Potion recieved\n
        ^does not belong to this function: "@type@"
        return false

    :
      >c-10,0,#red,
      ^func canUsePotionSpecial() - Potion recieved\n
      ^is not valid or equipped: "@type@"
      return false

  : // potion hasn't been brewed, it's been used,
    return false //or just can't be activated atm

/* Checks if a certain potion can be brewed.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func canBrewPotion(potionName)
  var result = loc.begin & item.potion ! potionName

  ?potionName = "strength"
    result = result & res.stone >= 20
  :?potionName = "experience"
    result = result & res.wood >= 20
  :?potionName = "healing"
    result = result & res.tar >= 20
  :?potionName = "lightning"
    result = result & res.bronze >= 20
  :?potionName = "vampiric"
    result = result & res.tar >= 10 & res.bronze >= 10
  :?potionName = "lucky"
    result = result & res.stone >= 10 & res.bronze >= 10
  :?potionName = "berserk"
    result = result & res.wood >= 10 & res.bronze >= 10
  :?potionName = "cleansing"
    result = result & res.wood >= 10 & res.tar >= 10
  :?potionName = "defensive"
    result = result & res.stone >= 10 & res.tar >= 10
  :?potionName = "invisibility"
    result = result & res.wood >= 10 & res.stone >= 10

  :
    result = false

  return result
/* Brews a certain potion.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func brewPotion(potionName)
  ?potionName = "strength"
    brew stone
  :?potionName = "experience"
    brew wood
  :?potionName = "healing"
    brew tar
  :?potionName = "lightning"
    brew bronze
  :?potionName = "vampiric"
    brew tar + bronze
  :?potionName = "lucky"
    brew stone + bronze
  :?potionName = "berserk"
    brew wood + bronze
  :?potionName = "cleansing"
    brew wood + tar
  :?potionName = "defensive"
    brew stone + tar
  :?potionName = "invisibility"
    brew wood + stone
  :
    >c-10,0,#red,
    ^ERROR: brewPotion() recieved
    ^incorrect potionName: @potionName@

  return


// Status effects

/* Returns each weapon's range.
Accounts for the Grasping Staff's
buff and Pallas's debuff.
************************************
DOESN'T ACCEPT WEAPONS, BUT SPECIFIC
KEYWORDS THAT REPRESENT THEM.
************************************ */
func getRange(weaponName)
  var result = null
  var isApplied = false
  var isApplied2 = false

  ?weaponName = "sword" & result = null
    result = u.sword_range
  :?weaponName = "sword big" & result = null
    result = u.sword_big_range
  :?weaponName = "hammer" & weaponName ! "heavy" & result = null
    result = u.hammer_range

  :?weaponName = "wand" & result = null
    result = u.wand_range
  :?weaponName = "crossbow" & result = null
    result = u.crossbow_range

  :?weaponName = "quarterstaff" & result = null
    result = u.staff_range
  :?weaponName = "staff" & result = null
    result = u.staff_range

  :?weaponName = "bardiche" & result = null
    ?weaponName = "ability"
      result = u.bardiche_ability_range
    :
      result = u.bardiche_range
  :?weaponName = "heavy hammer" & result = null
    ?weaponName = "ability"
      result = u.heavyHammer_ability_range
    :
      result = u.heavyHammer_range


  ?buffs.string = "buff_range" & !isApplied
    result += u.grasping_buff
    isApplied = true

  ?debuffs.string = "pallas_phase2_debuff"
    result--
    isApplied2 = true

  ?result ! null
    ?result >= u.grasping_cap
      return u.grasping_cap
    : 
      return result

/* Returns foe's damage, accounting for
any damage-reduction debuffs applied.

weakenAmount = if applied, amount of damage
               deducted to the foe by the
               weapon you used for it.
feebleCount = if applied, amount of Feeble
              debuffs your Cultist Mask can
              apply.
***************** WARNING *****************
  Since these are variable, they can't be
  calculated, so they have to be provided
         for this function to work.
******************************************* */
func getFoeDamage(weakenAmount, feebleCount)
  var result = foe.damage
  var isApplied = false
  var isApplied2 = false

  ?foe.debuffs.string = "feeble" & !isApplied
    result -= (2 * feebleCount)
    isApplied = true
  ?foe.debuffs.string = "debuff_damage" & !isApplied2
    result -= weakenAmount
    isApplied2 = true

  ?result < 0
    result = 0

  return result

/* Returns true if the foe is
vulnerable to Chill and if the
debuff isn't applied yet. */
func canApplyChill()
  return
  ^foe.debuffs.string ! "chill:6" &
  ^foe ! "immune_to_debuff_chill"
/* Returns true if the foe is
vulnerable to Weaken and if the
debuff isn't applied yet. */
func canApplyWeaken()
  return
  ^foe.debuffs.string ! "damage" &
  ^foe ! "immune_to_debuff_damage"
/* Returns true if the foe is
vulnerable to Burn and if the
debuff isn't applied yet. */
func canApplyBurn()
  return
  ^foe.debuffs.string ! "dot" &
  ^foe ! "immune_to_debuff_dot"

/* checks if the foe is vulnerable
to at least one of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canDebuffAny()
  return
  ^canApplyChill() |
  ^canApplyWeaken() |
  ^canApplyBurn()
/* checks if the foe is vulnerable
to ALL of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canDebuffAll()
  return
  ^foe ! "immune_to_debuff_chill" &
  ^foe ! "immune_to_debuff_damage" &
  ^foe ! "immune_to_debuff_dot"



// Damage min-maxing

var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)

  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3

    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?mode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moonTimer++
    moonFrame = moonTimer % 4

    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?mode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    ?foe.distance <= 5
      equipL moon
    :
      equipL @weapon2@
    equipR @weapon1@

  return

/* Faster moondialing variant, aka Bursting.
************************************************
REQUISITE: HAVING 10 *21 SPEED ENCHANTED SWORDS.
************************************************ */
var burstingTimer = 0
func doBursting(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10)
  burstingTimer++

  equipL moon
  ?burstingTimer = 0
    equipR @s1@

  :?burstingTimer = 1
    equipR @s2@

  :?burstingTimer = 2
    equipR @s3@

  :?burstingTimer = 3
    equipR @s4@

  :?burstingTimer = 4
    equipR @s5@

  :?burstingTimer = 5
    equipR @s6@

  :?burstingTimer = 6
    equipR @s7@

  :?burstingTimer = 7
    equipR @s8@

  :?burstingTimer = 8
    equipR @s9@

  :?burstingTimer = 9
    equipR @s10@
  :
    return

/* AAC = Attack Animation Cancelling
Widely used trick to enable a
massive attack speed boost*/
func doAAC(itemLeft, itemRight)
  ?item.left.state = 3
    equipL @itemLeft@
    equipL @item.left@
  ?item.right.state = 3
    equipR @itemRight@
    equip @item.right@ // equip works for two-handed items as well

  // return


// Others

func isDead()
  return foe.state = 4 | foe.state = -1 // foe death states



// *******************************************************
//                  END OF "Combat.txt"                   
// *******************************************************
