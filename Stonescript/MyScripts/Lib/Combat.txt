// *******************************************************
//                       Combat.txt                       
// *******************************************************


/* FILE INFO
  Combat functions library
  Made by MetalEagle26 (Tom Crow)

This library provides some game-related
functions to make the task of doing a
farming script easier.

- How to use:
  var c = new Combat

- Tip: If you want to use the variables here,
       put c.Main() at the top of your script.

- Use the functions that you need like this:
  ?c.useBlade() // example */



// IMPORTS

var p
p = import MyScripts/Lib/Performance



// VARIABLES

// Status

var midhp
var lowhp
var hihp



// FUNCTIONS

func Main()
  midhp = maxhp / 2
  lowhp = maxhp / 3
  hihp = (4 * maxhp) / 5

  ?loc.loop
    apsTimer = 0

  return


// Lost items

func canUseBlade()
  return totaltime >= p.bladeDelay & item.CanActivate()

// cannot be interrupted, doesn't need a cooldown check
func useBlade()
  equip blade
  activate R

  p.bladeDelay = totaltime + p.bladeCd

  return

/* Checks if Blade of the Fallen God
can be used in 2 screens of distance,
according to a certain screen index. */
func canUseBladeDS(nScreen)
  return canUseBlade()
  ^& screen.i = nScreen

var slideCount = 0 // counter to give screen.Next() time to slide
func useBladeDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useBlade()
      screen.ResetOffset()
      return


func canUseArm()
  return totaltime >= p.armDelay &
  ^3 < foe.distance & foe.distance < 9
  ^& item.CanActivate()

func useArm()
  equip arm
  activate R

  p.armDelay = totaltime + p.armCd

  return


func canUseMask()
  return totaltime >= p.maskDelay & item.CanActivate()

func useMask()
  equipL triskelion
  equipR mask
  activate R

  p.maskDelay = totaltime + p.maskCd

  return

func canUseMaskDS(nScreen)
  return canUseMask()
  ^& screen.i = nScreen

func useMaskDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20
  
  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useMask()
      screen.ResetOffset()
      return


func canUseFTali()
  return
  ^summon.GetId() ! "cinderwisp" &
  ^totaltime >= p.fTaliDelay &
  ^item.CanActivate() |
  ^(item.left = "fire_talisman" & item.left.state = 2) |
  ^(item.right = "fire_talisman" & item.right.state = 2)

func canHideFTali()
  return summon.GetId() = "cinderwisp"
  ^& totaltime >= p.fTaliDelay
  ^& item.CanActivate() |
  ^(item.left = "fire_talisman" & item.left.state = 2) |
  ^(item.right = "fire_talisman" & item.right.state = 2)

func useFTali(hand)
  ?hand = "l"
    equipL fire_talisman
    activate L
  :?hand = "r"
    equipR fire_talisman
    activate R

  p.fTaliDelay = totaltime + p.fTaliCd + p.castTime

  return

/* Checks if you can use the cinderwisp's "devour"
ability. */
func canUseCind()
  return summon.GetId() = "cinderwisp"
  ^& totaltime >= p.cindDelay & item.CanActivate()

/* Checks if the estimated damage of
cinderwisp's "devour" ability will kill the foe,
leaving a damage margin.
  - foeTotalHP: foe hp + armor
  - nIgnitions: amount of ignition debuffs currently
                applied to the foe.
  - cindDmg: damage dealt by cinderwisp for each ignition.
  - margin: number representing a health margin to add
            to the remaining foe's health. This is
            necessary because the ability has a cast time
            that will alter the estimations done here.
            Send 0 if you don't want to use a margin. */
func canKillCind(foeTotalHP, nIgnitions, cindDmg, margin)
  return foeTotalHP <= (nIgnitions * cindDmg) + margin

func useCind()
  activate cinderwisp
  p.cindDelay = totaltime + p.cindCd + p.castTime
  return


func canUseAETali()
  return
  ^summon.GetId() ! "voidweaver" &
  ^totaltime >= p.aeTaliDelay &
  ^item.CanActivate() |
  ^(item.left = "aether_talisman" & item.left.state = 2) |
  ^(item.right = "aether_talisman" & item.right.state = 2)

func useAETali(hand)
  ?hand = "l"
    equipL aether_talisman
    activate L
  :?hand = "r"
    equipR aether_talisman
    activate R

  p.aeTaliDelay = totaltime + p.aeTaliCd + p.castTime

  return

/* Checks if you can use the voidweaver's "devour"
ability. */
func canUseWeav()
  return summon.GetId() = "voidweaver"
  ^& totaltime >= p.weavDelay & item.CanActivate()

func useWeav()
  activate voidweaver
  p.weavDelay = totaltime + p.weavCd + p.castTime
  return

func canUseWeavDS(nScreen)
  return canUseWeav()
  ^& screen.i = nScreen

func useWeavDS()
  ?slideCount = 0
    screen.Next()
    slideCount = 20

  :?slideCount > 0
    slideCount--
  
    ?slideCount = 0
      useWeav()
      screen.ResetOffset()

      return


/* Checks if you can use the
bashing shield's ability. */
func canBash()
  return totaltime >= p.bashDelay & !ai.idle
  ^& 11 <= foe.distance & foe.distance <= 15
  ^& item.CanActivate()

func bash(lItem)
  equipL @lItem@
  equipR bashing shield

  p.bashDelay = totaltime + p.bashCd

  return


// Special Weapons

func canUseHamm()
  return totaltime >= p.hammDelay &
  ^item.CanActivate() |
  ^(item.right = "heavy hammer" &
  ^item.right.state = 2)

var hammCdSlower
func canUseHamm2()
  hammCdSlower = item.GetCooldown("hammer") <= 0
  return hammCdSlower &
  ^item.CanActivate() |
  ^(item.right = "heavy hammer" &
  ^item.right.state = 2)

func useHamm(yourHamm)
  equip @yourHamm@
  activate R

  p.hammDelay = totaltime + p.hammCd + p.castTime

  return


func canUseBard()
  return totaltime >= p.bardDelay &
  ^item.CanActivate() |
  ^(item.right = "bardiche" &
  ^item.right.state = 2)

var bardCdSlower
func canUseBard2()
  bardCdSlower = item.GetCooldown("bardiche") <= 0
  return bardCdSlower &
  ^item.CanActivate() |
  ^(item.right = "bardiche" &
  ^item.right.state = 2)

func useBard(yourBard)
  ?foe.distance < 10
    equip @yourBard@
    activate R

    p.bardDelay = totaltime + p.bardCd + p.castTime

  return


/* Checks if you can use the
dashing shield's ability. */
func canDash()
  return item.GetCooldown("dash") <= 0 & !ai.idle
  ^& 11 <= foe.distance & foe.distance <= 15
  ^& item.CanActivate()

func dash(lItem, yourDshield)
  equipL @lItem@
  equipR @yourDshield@

  p.dashDelay = totaltime + p.dashCd

  return


func canUseQstaff()

  ?totaltime >= p.qstaffDelay
    return item.CanActivate() |
    ^(item.right = "quarterstaff"
    ^& item.right.state = 2)

  :
    return false

func canUseQstaff_OG()
  var result = false

  ?item.CanActivate()
    ?item.GetCooldown("quarterstaff") <= 0
      result = true
    :?item.right = "quarterstaff" & item.right.state = 2
      result = true

  return result

// recieves a string
func useQstaff(yourQstaff)
  equip @yourQstaff@
  activate R

  p.qstaffDelay = totaltime + p.qstaffCd

  return


func canUseMind()
  return item.GetCooldown("mind") <= 0 & item.CanActivate()


// Tools

func canUseHatchet()
  return item.GetCooldown("hatchet") <= 0
  ^& item.CanActivate()
  ^& harvest.distance < 5
  ^& item.right = "hatchet"

func useHatchet()
  activate R
  return


// Potions

func canUsePot()
  return item.potion ! "empty" & item.CanActivate()

/* Checks if a healing type potion
can be used.
Healing type potions are considered:
  - healing
  - defensive
  - vampiric */
func canUsePotHeal()
  ?canUsePot()
    ?item.potion = "healing" |
    ^item.potion = "vampiric"
      return hp < lowhp

    :?item.potion = "defensive"
      return hp < midhp
    
    :
      return false
  :
    return false

/* Determines if a damage buff potion
is brewed. Generally used for bosses.
Potions related:
  - berserk
  - lucky */
func canUsePotDmg()
  return canUsePot() &
  ^(item.potion = "berserk" | item.potion = "lucky")

/* Determines if a special potion
can be activated, given a special
condition that's different for each potion type.
Valid potion types and conditions:
  - cleansing | min. no. of debuffs to cleanse
  - strength | min. amount of foe's armor
  - lightning, | ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  - experience | min. no. of foes to activate
  - invisibility | NONE (will activate if foe = boss)
    + (send true as condition for this type) */
func canUsePotSpecial(type,cond)
  ?canUsePot()

    ?item.potion = type
      ?item.potion = "cleansing"
        return hp < midhp &
        ^debuffs.count >= cond
        // ^^^ = no. of debuffs to cleanse
    
      :?item.potion = "strength"
        return foe.armor & foe.armor > cond

      :?item.potion = "lightning"
      ^|item.potion = "experience"
        return foe.count >= cond

      :?item.potion = "invisibility"
        return foe = boss

      :
        >c-10,0,#red,
        ^func canUsePotSpecial() - Potion recieved\n
        ^does not belong to this function: "@type@"
        return false

    :
      >c-10,0,#red,
      ^func canUsePotSpecial() - Potion recieved\n
      ^is not valid or equipped: "@type@"
      return false

  : // potion hasn't been brewed, it's been used,
    return false //or just can't be activated atm


// Others

var moonTimer = 0
var moonFrame
func doMoondial(weapon1, weapon2, mode)

  ?mode = 0 // Normal moondialing
    moonTimer++
    moonFrame = moonTimer % 3

    ?moonFrame = 1
      equipL moon
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?mode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moonTimer++
    moonFrame = moonTimer % 4

    ?moonFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moonFrame = 2
      equipL moon
      equipR @weapon1@
    :?moonFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moonFrame = 4
      equipL moon
      equipR @weapon2@
  
  :?mode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?mode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    ?foe.distance <= 5
      equipL moon
    :
      equipL @weapon2@
    equipR @weapon1@

  return

var apsTimer = 0
/* Fastest moondialing variant with all dual D rune swords.
Requires them all to be *21 speed enchanted. */
func doAps(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10)
  apsTimer++

  equipL moon
  ?apsTimer = 0
    equipR @s1@

  :?apsTimer = 1
    equipR @s2@

  :?apsTimer = 2
    equipR @s3@

  :?apsTimer = 3
    equipR @s4@

  :?apsTimer = 4
    equipR @s5@

  :?apsTimer = 5
    equipR @s6@

  :?apsTimer = 6
    equipR @s7@

  :?apsTimer = 7
    equipR @s8@

  :?apsTimer = 8
    equipR @s9@

  :?apsTimer = 9
    equipR @s10@
  :
    return


func doAAC(itemLeft, itemRight)
  ?item.left.state = 3
    equipL @itemLeft@
    equipL @item.left@
  ?item.right.state = 3
    equipR @itemRight@
    equip @item.right@ // equip works for two-handed items as well

  return



// *******************************************************
//                  END OF "Combat.txt"                   
// *******************************************************
