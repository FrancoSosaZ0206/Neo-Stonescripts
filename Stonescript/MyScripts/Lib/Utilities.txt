// *******************************************************
//                     Utilities.txt                      
// *******************************************************



/* FILE INFO
  Library of utilities
  Made by MetalEagle26 (Tom Crow)

DESCRIPTION
This library provides a pack of useful
  general purpose variables and
  functions to make your script-making
  tasks easier!

HOW TO IMPORT
  var u = new Lib/Utilities

HOW TO USE
  ?u.sec // example */



// /////////////////////////////////////////// //

// IMPORTS

var uimkr = new MyScripts/Lib/UI_Maker



// /////////////////////////////////////////// //

// VARIABLES

// Units

var sec = 30 // frames
var scr = 69 // 1 screen = 69 units

// Weapon Ranges
var bardiche_range = 9
var bardiche_ability_range = 7
var heavyHammer_range = 7 // CHECK
var heavyHammer_ability_range = 21 // CHECK

// These count both for dashing and bashing shields:
var dash_range_min = 11
var dash_range_max = 15

var hatchet_range = 5

var star_stone_range = 12

var sword_range = 5
var hammer_range = 5
var quarterstaff_range = 5
var sword_big_range = 6
var wand_rune_range = 20
var staff_range = 20
var crossbow_range = 22
var crossbow_rune_range = 23


// Special stats

// Hidden wands
var wandStoneArmor = 0      // gravity
var wandPoisonArmor = 6     // plague
var wandVigorArmor = 1      // reset
var wandAetherArmor = 14    // calamity
var wandFireArmor = 4       // explosive
var wandIceArmor = 3        // frost

// Hidden staves
var staffStoneArmor = 3     // acrobatic
var staffPoisonArmor = 8    // berserker
var staffVigorArmor = 4     // prevention
var staffAetherArmor = 2    // grasping
var staffFireArmor = 6      // infernal
var staffIceArmor = 1       // eternity

/* the added range that the
Grasping Staff's ability adds: */
var grasping_buff = 10
var grasping_cap = 22



// /////////////////////////////////////////// //

// FUNCTIONS

func max(n1,n2)
  ?n1 >= n2
    return n1
  :
    return n2

/* Finds the largest string in an array of strings. */
func getLargestStr(arrStr)
  ?arrStr.Count() > 0
    var maxStr = arrStr[0]
    var maxInd = -1

    for str : arrStr
      ?string.Size(str) > string.Size(maxStr)
        maxStr = str

    return maxStr
  
  :
    return null

func myFormatDigital(frames)
  ?frames <= 0
    return "00:00"
  :
    var timeStr
    var secs
    var mins
    var secStr
    var minStr

    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins
      
    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
    
    return minStr + ":" + secStr

/* returns time in a similar format to time.FormatDigital,
   but with frame presition. */
func formatSpeedrun(frames)

  var timeStr = "00:00 00f"

  ?frames > 0

    var frms
    var secs
    var mins
    var frmStr
    var secStr
    var minStr

    frms = frames % 30 // the rest of the division is the added frames between each second
    secs = frames/30
    mins = (frames/30)/60

    secs -= mins*60

    ?frms < 10
      frmStr = "0" + frms
    :
      frmStr = frms

    frmStr += "f"

    ?secs < 10
      secStr = "0" + secs
    :
      secStr = secs
      
    ?mins < 10
      minStr = "0" + mins
    :
      minStr = mins

    timeStr = minStr + ":" + secStr + " " + frmStr
    
  return timeStr


// Strings

/* shows a big string, broken down into several lines.
PARAMETERS:
  - str = the string in question
  - x
  - y
  - maxW = maximum width to show the string
  - col (optional) = resulting text's color
  - isUI:
    - true = returns an UI component with the string
    - false = prints out the broken down string directly.
              DOES NOT RETURN ANYTHING. */
func showBigStr(x,y,maxW,str,col,isUI)

  ?isUI
    var txtbox
    var panel

    txtbox = uimkr.mkTxtbox(1,1,maxW,null,
    ^top_left,top_left,
    ^str,null,col)

    panel = uimkr.mkPanel(x,y,
    ^txtbox.w + 2,
    ^txtbox.h + 2,
    ^top_left,top_left,
    ^col,-1,txtbox)
    
    return panel
  
  :
    var arr = string.Break(str, maxW)

    for i = 0 .. arr.Count()-1
      ?col
        >`@x@,@y + i@,@col@,@arr[i]@
      :
        >`@x@,@y + i@,@arr[i]@

    return

/* Shows a string centered in the screen,
   breaking it down into several lines if necessary.
PARAMETERS:
  - y
  - maxW = maximum width to show the string
  - str = the string in question
  - col = output color of the string
  - isUI:
    - true = returns an UI component with the string
    - false = prints out the centered, broken down
              string directly.
              DOES NOT RETURN ANYTHING. */
func showStrCtr(y,maxW,str,col,isUI)

  ?isUI
    var txtbox
    var panel

    txtbox = uimkr.mkTxtbox(1,1,maxW,null,
    ^top_left,top_left,
    ^str,center,col)

    panel = uimkr.mkPanel(
    ^- (txtbox.w / 2),y,
    ^txtbox.w + 2,
    ^txtbox.h + 2,
    ^center_center,center_centere,
    ^col,-1,txtbox)
    
    return panel

  :

    var arr = string.Break(str, maxW)

    for i = 0 .. arr.Count()-1
      var x
      x = - ( string.Size(arr[i]) - 1 ) / 2
      ?col
        >c@x@,@y + i@,@col@,@arr[i]@
      :
        >c@x@,@y + i@,@arr[i]@

    return


// Helper functions

/* Converts widely used color names into
their respective hexadecimal representation. */
func colorToHex(colorName)
  ?colorName = "red"
    return #FF0000
  :?colorName = "orange"
    return #FF7518
  :?colorName = "yellow"
    return #FFFF00
  :?colorName = "gold"
    return #E49B0F
  :?colorName = "blue"
    return #0000FF
  :?colorName = "cyan"
    return #00FFFF
  :?colorName = "magenta"
    return #FF00FF
  :?colorName = "pink"
    return #E0115F
  :?colorName = "purple"
    return #800080
  :?colorName = "violet"
    return #7F00FF
  :?colorName = "green"
    return #008000
  :?colorName = "darkGreen"
    return #023020
  :?colorName = "white"
    return #FFFFFF
  :?colorName = "gray"
    return #808080
  :?colorName = "black"
    return #000000
  :?colorName = "brown"
    return #7B3F00
  :?colorName = "turquoise" | colorName = "turquesa"
    return #40E0D0
  :?colorName = "rainbow" | colorName = "rgb"
    return #rainbow
  :
    >c-20,0,#red,ERROR: colorToHex() got unexisting color: @colorName@



// *******************************************************
//                 END OF "Utilities.txt"                 
// *******************************************************
