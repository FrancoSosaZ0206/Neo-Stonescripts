// ///////////////// IMPORTS ///////////////// //

var u = import My/Lib/Utilities

// ................ Variables ................ //

// var sec = 30        // Frames
var currhp = 0      // foe's current hitpoints (with armor)
var nethp = 0       // foe's net maximum hitpoints (with armor)

var hits      = 0   // hit counter
var dmg       = 0   // current damage dealt
var totalDmg  = 0   // total damage dealt
var startTime = 0   // timestamp for the beginning of the fight
var auxhp     = 0   // auxiliar variable to compare with currhp

var FRM = "N/A"     // frames elapsed from first hit
var FPH = "N/A"     // frames per hit >>> hit frequency | frames elapsed from each hit to the next
var HPS = "N/A"     // hits per second
var DPF = "N/A"     // damage per frame
var DPS = "N/A"     // damage per second

var pnl = null
var txt = null

var dataArr = [
^"DPS#|#{0}",

^"###DPS#METER###\n"+
^"#·##·##·##·##·#\n"+
^"#No.#Hits#{0}\n"+
^"#Hits/Sec#{1}\n"+
^"#Dmg#/Hit#{2}\n"+
^"#Dmg#/Frm#{3}\n"+
^"#Dmg#/Sec#{4}"
^]

// ................ Functions ................ //

// DATA HANDLING

func updateData(frameRate)
  ?frameRate > 0 & totaltime % frameRate = 0 &
  ^(foe = "boss" | foe = "monarch")

    currhp  = foe.hp + foe.armor
    nethp   = foe.maxhp + foe.maxarmor

    ?0 < currhp & currhp < nethp // boss lost hp/armor, but isn't dead

      ?auxhp > currhp // if current hp updates
        hits += 1 // we count a hit
        dmg       = auxhp - currhp // we get the damage dealt from the difference
        totalDmg  = totalDmg + dmg // and we accumulate it in this variable

    : // else, reset temporal variables
      startTime = totaltime
      hits      = 0
      dmg       = 0
      totalDmg  = 0


    FRM = totaltime - startTime // total time minus the time the first hit was dealt
    ?hits > 1
      FPH = FRM      / (hits /*- 1*/) // -1 is there to avoid stat flicking
    :
      FPH = "N/A"

    ?FPH ! "N/A"
      HPS = u.sec      / FPH
    :
      HPS = "N/A"
      
    ?FRM > 0
      DPF = totalDmg / FRM // damage accumulated - no. frames elapsed
    :
      DPF = "N/A"

    ?DPF ! "N/A"
      DPS = DPF  * u.sec
    :
      DPS = "N/A"

    auxhp = currhp

func dataToString(mode)
  ?mode = "slim" | mode = "small"
    return string.Format(dataArr[0], DPS)
  :
    return string.Format(dataArr[1],
    ^               hits,HPS,dmg,DPF,DPS)

// PRINT

func print(x, y, colorHex, mode)
  >`@x@,@y@,@colorHex@,@dataToString(mode)@

// UI

func uiMngr(x, y, colorHex, mode)
  ?canInitUi()
    mkUi(x,y,colorHex,mode)
  /*:?canRegenUi()
    dlUi()
    mkUi(x,y,colorHex,mode)*/
  :
    updateUi(mode)

func canInitUi()
  return !(pnl & txt)

// Regenerates ui components every 3 seconds.
func canRegenUi()
  return (pnl | txt) & (totaltime % (3 * u.sec) = 0)

func dlUi()
  txt.Recycle()
  txt = null
  pnl.Recycle()
  pnl = null

func mkUi(x, y, colorHex, mode)
  // Panel presets
  var panelStyle = -3

  // Textbox presets
  var dataStr = dataToString(mode)
  var txtW = null
  var txtH = null

  ?mode = "slim" | mode = "small"
    panelStyle = -1
    txtW = string.Size(dataStr)
    txtH = 1
  :
    txtW = string.Size(
    ^         u.getLargestStr(
    ^             string.Split(dataStr, "\n")))

    txtH = string.Split(dataStr,"\n").Count()

  txt = ui.AddText()
  txt.text = dataStr
  txt.x = 1
  txt.y = 1
  txt.w = txtW
  txt.h = txtH
  txt.anchor = "top_left"
  txt.dock = "top_left"
  txt.color = colorHex

  pnl = ui.AddPanel()
  pnl.x = x
  pnl.y = y
  pnl.w = txt.w + 2
  pnl.h = txt.h + 2
  pnl.anchor  = "bottom_right"
  pnl.dock    = "bottom_right"
  pnl.color   = colorHex
  pnl.style   = panelStyle

  pnl.Add(txt)

func updateUi(mode)
  txt.text = dataToString(mode)

  // force visibility
  pnl.visible = true
  txt.visible = true
