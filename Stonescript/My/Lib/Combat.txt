//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀ START OF "Combat" ▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //

/* // ///////////// FILE INFO //////////////// //

Combat functions library
Made by IronHawk (Tom Crow)

. ................ Description ................ .

  This library provides some game-related
  functions to make the task of doing a
  farming script easier.

. ................. Importing ................. .

  var c = new Combat

. .................... Tip .................... .

  If you want to use the variables here,
  put c.Init() at the top of your script.

. ................... Usage ................... .

  ?c.canUseAbility("blade")
    c.useAbility_TH("blade")

. ...................................... .

Enjoy! */

// ///////////////// IMPORTS ///////////////// //

var u = import My/Lib/Utilities
var s = import My/Lib/Stats

// //////////////// VARIABLES //////////////// //

// Status

var midhp
var lowhp
var hihp


// Function-related

var slideCount = 0 // counter to give screen.Next() time to slide in _DS functions.

var moondialTimer = 0
var burstingTimer = 0
var burstingCdTimer = 0

var item_TH_IDs = [ // two-handed item IDs
^   "blade",
^   "arm",

^   "bardiche",
^   "heavy_hammer",
^   "quarterstaff",

^   "staff_poison",
^   "staff_vigor",
^   "staff_aether",
^   "staff_fire",
^   "staff_ice",
^   "staff_stone"
^]

var item_OH_IDs = [ // one-handed item IDs
^   "mask",
^   "hatchet",

// ^   "stone_talisman",
// ^   "poison_talisman",
// ^   "vigor_talisman",
^   "aether_talisman",
^   "fire_talisman",
// ^   "ice_talisman",

^   "wand_poison",
^   "wand_vigor",
^   "wand_aether",
^   "wand_fire",
^   "wand_ice",
^   "wand_stone"
^]

var table_itemDS = [ // IDs of items' abilities that can be used in 2 screens
^   "ID"    , "TARGET", "MAX" ,
^   "blade" , null    , null  ,
^   "mask"  , null    , null
^]


// Others

var permapotSetup = loc.stars > 10 // only true from yellow onwards
var potionType = null

// //////////////// FUNCTIONS //////////////// //

func Init()
  midhp = maxhp / 2
  lowhp = maxhp / 3
  hihp = (4 * maxhp) / 5

  ?loc.loop
    permapotSetup = false

// ................. GLOBAL ................. //

/* Returns true if a given weapon's special ability can be activated.

Valid abilityID values:
- blade >> Blade of the Fallen God
- mask >> Cultist Mask
- arm >> Skeleton Arm (REQUIRES GAINING AT LEAST 1 PICK-POCKET BUFF)
- bash >> Bashing Shield
- dash >> Dashing Shield
- bardiche
- heavy_hammer
- quarterstaff
- mind >> Mindstone
- hatchet
- voidweaver >> Aether Talisman's summon
- cinderwisp >> Fire Talisman's summon
- staff + <name>, staff + <element> >> Hidden staves
- wand + <name>, wand + <element> >> Hidden wands
- <element>_talisman >> Talismans */
func canUseAbility(abilityID)
  var result = false

  // Valid ID
  ?s.ability_table.Contains(abilityID)
    result = item.CanActivate() &
    ^item.GetCooldown(abilityID) <= 0

    ?abilityID = "bash" | abilityID = "dash"
      result = result & s.inRange("dash") & !ai.idle

    :?abilityID = "arm"
      result = result & // item.CanActivate("arm") &
      ^s.inRange("arm") &
      ^buffs.string = "pick_pocket"

    :?abilityID = "hatchet"
      result = (result & loc = "deadwood_valley" &
      ^         s.inRange(abilityID)) |
      ^isCasting(abilityID) // won't get interrupted

    :?abilityID = "bardiche" |
    ^abilityID = "heavy_hammer"
      result = (result & s.inRange(abilityID + " ability")) |
      ^isCasting(abilityID) // won't get interrupted

    :?abilityID = "talisman" // interruptible abilities
      result = result | isCasting(abilityID) // make sure not to change it while casting the ability

    // Special case, stone wand doesn't require armor.
    :?abilityID = "wand_stone"
      result = result & foe.count > 1 &
      ^item.CanActivate("wand_stone")

    :?(abilityID = "staff" & abilityID ! "quarterstaff") |
    ^ abilityID = "wand"
      result = result &
      ^((10 * armor) + armor.f > 10 * s.getArmor(abilityID))

      ?abilityID = "wand_poison"
        result = result &
        ^!(foe = "immune_to_debuff_damage" |
        ^  encounter.eliteMod = "tenacious")
      :?abilityID = "wand_ice"
        result = result &
        ^!(foe = "immune_to_stun" |
        ^  encounter.eliteMod = "tenacious")

    :?s.talisman_table.Contains(abilityID) // it's a summon
      result = result & isSummoned(abilityID)

      ?abilityID = "voidweaver"
        result = result & canUnmakeVoidweaver()
      :?abilityID = "cinderwisp"
        ?foe.debuffs.string
          result = result & (foe.debuffs.string = "ignition")
        :
          result = false
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility\nCAUSE: unknown <abilityID>:\n\n" + abilityID, false)
    loc.Pause()

  return result

/* Activates a two-handed item's ability.

itemName = your item to activate.

Valid abilityID values:
- blade >> Blade of the Fallen God
- arm >> Skeleton Arm
- bardiche
- heavy + hammer >> Heavy Hammer
- quarterstaff
- staff + <element> + hidden >> Hidden staves */
func useAbility_TH(abilityID, itemName)
  ?item_TH_IDs.Contains(abilityID)
    equip @itemName@
    activate R

  : // invalid abilityID
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_TH\nCAUSE: <abilityID> unknown:\n\n" + abilityID, false)
    loc.Pause()
/* Activates a one-handed item's ability.

itemName = your item to activate.

Valid abilityID values:
- hatchet
- mask >> Cultist Mask
- <element> + talisman >> Talismans
- wand <element> + hidden >> Hidden wands */
func useAbility_OH(abilityID, itemName, hand)
  ?item_OH_IDs.Contains(abilityID)
    // special one-handed weapons equipment logic
    ?abilityID = "hatchet" | abilityID = "mask"
      equipR @abilityID@
      activate R

    // normal equipment logic
    :?hand = "l" | hand = "left"
      equipL @itemName@
      activate L

      // talismans equipment logic
      ?abilityID = "talisman" & s.inRange("dash")
        ?canUseAbility("bash")
          equipR bash
        :?canUseAbility("bash")
          equipR dash

    :?hand = "r" | hand = "right"
      equipR @itemName@
      activate R

      // talismans equipment logic
      ?abilityID = "talisman"
        ?pickup.distance < 15
          equipL star
        :?ai.walking & !s.inRange("triskelion")
          equipL triskelion
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_OH\nCAUSE: unknown <hand>:\n\n" + hand, false)
      loc.Pause()
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_T\nCAUSE: unknown <abilityID>:\n\n" + abilityID, false)
    loc.Pause()

/* Returns true if a given item is equipped. */
func isEquipped(itemName)
  return item.left = itemName | item.right = itemName
/* Returns true if an attack is being casted. */ 
func isCasting(itemName)
  return
  ^(item.left = itemName & item.left.state = 2) |
  ^(item.right = itemName & item.right.state = 2)

// ........... Double Screen (DS) ........... //

func isScreen_DS(itemName, type)
  var result = false
  ?!table_itemDS.Contains(itemName)
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS\nCAUSE: unknown <itemName>:\n\n" + itemName, false)
  :?!table_itemDS.Contains(type)
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS\nCAUSE: unknown <type>:\n\n" + type, false)
  :
    var scrTarget =
    ^table_itemDS[table_itemDS.IndexOf(itemName) + 
    ^             table_itemDS.IndexOf("TARGET")]

    ?type = "TARGET"
      result = (screen.i = scrTarget)
    : // type = "MAX"
      result = (scrTarget =
      ^table_itemDS[table_itemDS.IndexOf(itemName) + 
      ^            table_itemDS.IndexOf("MAX")])
  
  return result
func screenMngr_DS(itemName, scrTarget, scrMax)
  // Entry sanitization
  itemName = string.ToLower(itemName)

  // Error handling
  ?!table_itemDS.Contains(itemName)
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: screenMngr_DS\nCAUSE: unknown <itemName>:\n\n" + itemName, false)
  :?scrMax < 0
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: screenMngr_DS\nCAUSE: invalid <scrMax>:\n\n" + scrMax, false)
  :?scrTarget ! math.Clamp(scrTarget, 0, scrMax)
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: screenMngr_DS\nCAUSE: invalid <scrTarget>:\n\n" + scrTarget, false)
  // OK, proceed
  :
    var itemI = table_itemDS.IndexOf(itemName)
    var targetI = table_itemDS.IndexOf("TARGET")
    var maxI = table_itemDS.IndexOf("MAX")
    ?loc.begin | // beginning of the game
    ^!(table_itemDS[itemI + targetI] & table_itemDS[itemI + maxI]) // or unset
      table_itemDS[itemI + targetI] = scrTarget
      table_itemDS[itemI + maxI] = scrMax
    :?loc.loop & !isScreen_DS(itemName, "MAX")
      table_itemDS[itemI + targetI] += 1
/* Checks if a weapon ability can be used in 2 screens
of distance, according to a certain screen index. */
func canUseAbility_DS(itemName)
  ?table_itemDS.Contains(itemName)
    return canUseAbility(itemName) &
    ^isScreen_DS(itemName, "TARGET")
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

    return false
func useAbility_DS(itemName)
  ?table_itemDS.Contains(itemName)
    ?slideCount = 0
      screen.Next()
      slideCount = 20

    :?slideCount > 0
      slideCount--

      ?slideCount = 0
        useAbility_TH(itemName, itemName)
        screen.ResetOffset()
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

// ....... Talisman / Summon specific ....... //

func isSummoned(summonName)
  return summon.GetId() = summonName
/* Checks if a summon can be invoked by its respective talisman. */
func canSummon(summonName)
  var talisman = s.getTalisman(summonName)
  ?talisman
    return canUseAbility(talisman) & !isSummoned(summonName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canSummon\nCAUSE: unknown <summonName>: " + summonName, false)
    return false

/* Checks if a summon can be hidden by its respective talisman. */
func canHide(summonName)
  var result = s.getTalisman(summonName)

  ?result
    return canUseAbility(result) & isSummoned(summonName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canHide\nCAUSE: unknown <summonName>: " + summonName, false)

  return result

/* Activates a summon's "Devour" ability.

Valid summonName values:
- voidweaver
- cinderwisp */
func devour(summonName)
  ?s.talisman_table.Contains(summonName)
    ?isSummoned(summonName)
      /*?summonName = ""
        activate */
      /*:?summonName = ""
        activate */
      ?summonName = "voidweaver"
        activate voidweaver
      :?summonName = "cinderwisp"
        activate cinderwisp
      /*:?summonName = ""
        activate */
      /*: // summonName = ""
        activate */
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: " + @summonName@ + " isn't summoned", false)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: unknown <summonName>:\n\n" + summonName, false)

/* Checks if the Voidweaver's devour ability
will successfully unmake a foe. */
func canUnmakeVoidweaver()
  return canUnmake() & foe ! "elite"

/* Checks if the cinderwisp's "devour" ability damage
will kill the foe.

cinderwispDmg: damage dealt by cinderwisp for each
              ignition.
margin: number representing a health margin to add
        to the remaining foe's health. This is
        necessary because the ability has a cast time
        that will alter the estimations done here.
        Send 0 if you don't want to use a margin. */
func canKillCinderwisp(cinderwispDmg, margin)
  var result = false
  var debuffCount = null // amount of debuffs stacked

  ?canUseAbility("cinderwisp") & debuffCount
    debuffCount = s.getEffectStat("foe","debuff","ignition","count")
    result = s.getTotalHP("foe") <= (debuffCount * cinderwispDmg) + margin

  return result
/* Checks if the maximum amount of ignition debuffs have been
applied to a certain foe.

ignitions_cap: maximum number of ignition debuffs
               that can be applied. Varies on upgrade level or
               boosted stat. */
func isCinderwispCap(ignitions_cap)
  ?foe.debuffs.string
    return foe.debuffs.string = ignitions_cap
  :
    return false

// ................. Potions ................ //

/* Checks if a certain potion can be brewed. */
func canBrewPotion()
  ?!potionType
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canBrewPotion\nCAUSE: <potionType> has not been set.\n\n", false)
    return false
  :
    // Entry sanitization
    potionType = string.ToLower(potionType)

    ?!s.potion_table.Contains(potionType)
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canBrewPotion\nCAUSE: unknown <potionType>:\n\n" + potionType, false)
      return false
    :
      var result = loc.begin & item.potion ! potionType

      ?potionType   = "strength"
        result = result & res.stone >= 20
      :?potionType  = "experience"
        result = result & res.wood >= 20
      :?potionType  = "healing"
        result = result & res.tar >= 20
      :?potionType  = "lightning"
        result = result & res.bronze >= 20
      :?potionType  = "vampiric"
        result = result & res.tar >= 10 & res.bronze >= 10
      :?potionType  = "lucky"
        result = result & res.stone >= 10 & res.bronze >= 10
      :?potionType  = "berserk"
        result = result & res.wood >= 10 & res.bronze >= 10
      :?potionType  = "cleansing"
        result = result & res.wood >= 10 & res.tar >= 10
      :?potionType  = "defensive"
        result = result & res.stone >= 10 & res.tar >= 10
      : // potionType  = "invisibility"
        result = result & res.wood >= 10 & res.stone >= 10

      return result
/* Brews a certain potion. */
func brewPotion()
  ?!potionType
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: brewPotion\nCAUSE: <potionType> has not been set.\n\n", false)
  :
    // Entry sanitization
    potionType = string.ToLower(potionType)

    ?!s.potion_table.Contains(potionType)
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: brewPotion\nCAUSE: unknown <potionType>:\n\n" + potionType, false)
    :
      ?potionType   = "strength"
        brew stone
      :?potionType  = "experience"
        brew wood
      :?potionType  = "healing"
        brew tar
      :?potionType  = "lightning"
        brew bronze
      :?potionType  = "vampiric"
        brew tar + bronze
      :?potionType  = "lucky"
        brew stone + bronze
      :?potionType  = "berserk"
        brew wood + bronze
      :?potionType  = "cleansing"
        brew wood + tar
      :?potionType  = "defensive"
        brew stone + tar
      : // potionType  = "invisibility"
        brew wood + stone

func canUsePotion()
  ?!potionType
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canBrewPotion\nCAUSE: <potionType> has not been set.\n\n", false)
    return false
  :
    // Entry sanitization
    potionType = string.ToLower(potionType)

    ?!s.potion_table.Contains(potionType)
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canBrewPotion\nCAUSE: unknown <potionType>:\n\n" + potionType, false)
      return false
    :
      return item.CanActivate() &
      ^      item.potion ! "empty" &
      ^      item.potion = potionType

// ............. Status effects ............. //

/* Returns true if the current foes the player is
facing can be unmade. */
func canDebuff()
  return
  ^!(foe.buffs.string = "buff_tenacious" | // tenacious foes can't be debuffed
  ^  foe.buffs.string = "buff_protection")
/* Returns true if the current foes the player is
facing can be unmade. */
func canUnmake()
  return 
  ^!(foe = "boss" |  // bosses are immune to unmake
  ^  foe = "monarch") // monarch foes can't be unmade

/* Returns true if the foe is
vulnerable to Chill and if a given
debuff count hasn't been reached. */
func canApplyChill(chillCount)
  ?chillCount < 1 | chillCount > 6
    u.showStrCtr(0,30,#red,"ERROR:\nFILE: Combat\nFUNCTION: canApplyChill\nCAUSE: invalid <chillCount>: " + chillCount, false)
    return false
  :
    return canDebuff() &
    ^(foe.debuffs.string ! "chill:" + chillCount) &
    ^foe ! "immune_to_debuff_chill"
/* Returns true if the foe is
vulnerable to Weaken and if the
debuff isn't applied yet. */
func canApplyWeaken()
  return canDebuff() &
  ^foe.debuffs.string ! "damage" &
  ^foe ! "immune_to_debuff_damage"
/* Returns true if the foe is
vulnerable to Burn and if the
debuff isn't applied yet. */
func canApplyBurn()
  return canDebuff() &
  ^foe.debuffs.string ! "dot" &
  ^foe ! "immune_to_debuff_dot"

/* Returns true if the foe is
vulnerable to Stun and if the
debuff isn't applied yet. */
func canApplyStun()
  return canDebuff() &
  ^!(foe.debuffs.string = "stun" | // already stunned
  ^  foe = "immune_to_stun") // can't stun

/* checks if the foe is vulnerable
to at least one of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction) */
func canApplyAny()
  ?canDebuff()
    return
    ^canApplyChill(6) |
    ^canApplyWeaken()
  :
    return false
/* checks if the foe is vulnerable
to ALL of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction) */
func canApplyAll()
  ?canDebuff()
    return
    ^canApplyChill(6) &
    ^canApplyWeaken()
  :
    return false

/* Returns true if the player is engaging in a fight.

This enables the player to benefit from effects
that are applied when engaging, like ai or A/a
affix items. */
func canEngage()
  return ai.walking &
  ^foe.distance =
  ^   math.Clamp(foe.distance,
  ^              s.getRange("dash_max") + 1,
  ^              s.getRange("socketed_shield") - 10)

// ........... Damage min-maxing ............ //

/* Moonjuggling is a trick that boosts dps
with 2 swords whose attack speed stat is
maxed out (+21 enchantment).

It's a cycle that repeats every 3 frames:
- In the first 2, the Moondial Stone is held
with each sword, boosting their attack speed
even further.
- In the last one, both swords are held to
spend the cooldown frame. */
func moonjuggle(weapon1, weapon2)
  /* moonjuggling isn't necessary or possible
  under these conditions, do
  dual wielding */
  ?debuffs.string = "stun" |
  ^debuffs.string = "chill" |
  ^buffs.string = "ʘ" // berserk potion
    equipL @weapon2@
    equipR @weapon1@
  : // Normal moonjuggling
    moondialTimer++
    var moondialFrame = moondialTimer % 3

    ?moondialFrame = 1
      equipL moon
      equipR @weapon1@
    :?moondialFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  /* For when you have just 1 +21 sword (weapon2 can be
  anything, it will not be used) */
  /*:?moondialMode = 3
    equipL moon
    equipR @weapon1@*/

/* Moonjuggling variant, aka Bursting.
Requires a minimum of 2 swords to cycle through.
Works with an unlimited number of swords

weaponsArr: array with all the swords to use.
            Every sword must have a +21 enchanted
            boosting its attack speed stat.

Usage example:
  doBursting([sword fire *max +21,
              sword ice *max +21,
              sword poison *max +21,
              sword vigor *max +21,
              sword aether *max +21]) */
func burst(weaponsArr)
  var n = weaponsArr.Count()

  ?n >= 2
    ?burstingTimer >= n - 1 // cooldown frame
      // cycle trough every weapon:
      equipL @weaponsArr[burstingCdTimer]@
      equipR @weaponsArr[burstingCdTimer + 1]@
      burstingCdTimer+= 2 // increment burstingCdTimer twice each loop

      ?burstingCdTimer >= n - 2
        burstingTimer = 0 // reset timer
        burstingCdTimer = 0

    : // bursting frame (different weapon every frame)
      equipL moon
      equipR @weaponsArr[burstingTimer]@
      burstingTimer++

  :
    u.showStrCtr(0,30,#red,"ERROR:\nFILE: Combat\nFUNCTION: doBursting\nCAUSE: <weaponsArr> was too small (had " + n + " weapons", false)

/* AAC = Attack Animation Cancelling
Widely used trick to enable a
massive attack speed boost.

It works by skipping the "perf"
animation/state of an item, interrupting
it by switching to another item momentarily. */
func AAC(itemLeft, itemRight)
  ?item.left.state = 3
    equipL @itemLeft@
    equipL @item.left@

  ?item.right.state = 3
    equipR @itemRight@
    equip @item.right@ // equip works for two-handed items as well

/* Smooth Casting is a trick where you
hold the triskelion stone every certain
amount of frames to enable walking while
dealing damage.

Requires berserk potion or Infernal
Staff's ability. */
func canSmoothCast()
  return !permapotSetup &
  ^buffs.string = "ʘ" & // berserk potion
  ^!(debuffs.string = "stun" |
  ^  debuffs.string = "chill" )
func smoothCast(itemName)
  ?totaltime % 2 = 0
    equipL triskelion
    equipR hatchet
  :
    equip @itemName@

/* Checks if the player can use "Knockback Farming",
a strategy where you can walk while damaging and
pushing back foes, minimizing the time the stonehead
is still.

Requires Smooth Casting. */
func canKbFarm()
  return foe ! "unpushable" & // immune to knockback
  ^!permapotSetup &
  ^canSmoothCast() & // smooth cast is required
  ^s.inRange("crossbow")
  // between dashing and crossbow range
  ^foe.distance =
  ^   math.Clamp(foe.distance,
  ^              s.getRange("dash_max"),
  ^              s.getRange("crossbow"))

func canEscape()
  return foe ! "ranged" &
  ^foe.distance < s.getRange("dash_min") &
  ^(canUseAbility("staff_stone") |
  ^ canUseAbility("mind"))

/* Stutterstepping is a technique that enables
walking with the Triskelion Stone while inside its
attack range (where the player would normally stop
to attack). */
func stutterStep()
  ?totaltime % 2 = 0 // equip every other frame
    equipR triskelion
  :
    equipR hatchet
  equipL sword 0* +0

//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀▄ END OF "Combat" ▀▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //