//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀ START OF "Combat" ▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //


/* // ///////////// FILE INFO //////////////// //

Combat functions library
Made by IronHawk (Tom Crow)

. ................ Description ................ .

  This library provides some game-related
  functions to make the task of doing a
  farming script easier.

. ................. Importing ................. .

  var c = new Combat

. .................... Tip .................... .

  If you want to use the variables here,
  put c.Init() at the top of your script.

. ................... Usage ................... .

  ?c.canUseAbility("blade")
    c.useAbility_TH("blade")

. ...................................... .

Enjoy! */


// ///////////////// IMPORTS ///////////////// //

var u = import My/Lib/Utilities
var s = import My/Lib/Stats


// //////////////// VARIABLES //////////////// //

// Status

var midhp
var lowhp
var hihp


// Function-related

var smiteScreen_Target = -1
var smiteScreen_Max = -1
var maskScreen_Target = -1
var maskScreen_Max = -1

var slideCount = 0 // counter to give screen.Next() time to slide in _DS functions.

var moondialMode = -1
var moondialTimer = 0
var burstingTimer = 0
var burstingCdTimer = 0

// Others

var isPermapotSetup = true


// //////////////// FUNCTIONS //////////////// //

func Init()
  midhp = maxhp / 2
  lowhp = maxhp / 3
  hihp = (4 * maxhp) / 5

  ?buffs.string = "⊙" // berserk potion
    moondialMode = 2
  :
    moondialMode = 0

  ?loc.begin
    smiteScreen_Target = 1
  :?loc.loop
    isPermapotSetup = false

// ............... GLOBAL ............... //

/* Returns true if a given weapon's special ability can be activated.

Valid abilityId values:
- blade >> Blade of the Fallen God
- mask >> Cultist Mask
- arm >> Skeleton Arm (REQUIRES GAINING AT LEAST 1 PICK-POCKET BUFF)
- bash >> Bashing Shield
- dash >> Dashing Shield
- bardiche
- heavy_hammer
- quarterstaff
- mind >> Mindstone
- hatchet
- voidweaver >> Aether Talisman's summon
- cinderwisp >> Fire Talisman's summon
- staff + <name>, staff + <element> >> Hidden staves
- wand + <name>, wand + <element> >> Hidden wands
- <element>_talisman >> Talismans */
func canUseAbility(abilityId)
  var result = false

  ?abilityId = "blade" | abilityId = "mask" |
  ^abilityId = "arm"                        |
  ^abilityId = "mind"                       |

  ^abilityId = "bash"  | abilityId = "dash" |

  ^abilityId = "heavy_hammer"              |
  ^abilityId = "bardiche"                  |
  ^abilityId = "quarterstaff"              |

  // ^abilityId = "stone_talisman"            |
  // ^abilityId = "poison_talisman"           |
  // ^abilityId = "vigor_talisman"            |
  ^abilityId = "aether_talisman"           |
  ^abilityId = "fire_talisman"             |
  // ^abilityId = "ice_talisman"              |

  ^abilityId = "voidweaver"                |
  ^abilityId = "cinderwisp"                |

  ^abilityId = "wand_stone"                |
  ^abilityId = "wand_poison"               |
  ^abilityId = "wand_vigor"                |
  ^abilityId = "wand_aether"               |
  ^abilityId = "wand_fire"                 |
  ^abilityId = "wand_ice"                  |

  ^abilityId = "staff_stone"               |
  ^abilityId = "staff_poison"              |
  ^abilityId = "staff_vigor"               |
  ^abilityId = "staff_aether"              |
  ^abilityId = "staff_fire"                |
  ^abilityId = "staff_ice"
    result = item.CanActivate() &
    ^item.GetCooldown(abilityId) <= 0

    ?abilityId = "bash" | abilityId = "dash"
      result = result & isDashingRange() & !ai.idle
    :?abilityId = "arm"
      result = result & item.CanActivate("arm") &
      ^foe.distance <= s.getRange("arm") &
      ^buffs.string = "pick_pocket"
    :?abilityId = "hatchet"
      result = result & loc = "deadwood_valley"

    :?abilityId = "hatchet"
      result = (result & // and it's in range
      ^foe.distance <= s.getRange(abilityId)) |
      ^isCasting(abilityId) // won't get interrupted

    :?abilityId = "bardiche" |
    ^abilityId = "heavy_hammer"
      result = (result & // and it's in range
      ^foe.distance <= s.getRange(abilityId + " ability")) |
      ^isCasting(abilityId) // won't get interrupted

    :?abilityId = "quarterstaff" | abilityId = "talisman" // interruptible abilities
      result = result | isCasting(abilityId) // make sure not to change it while casting the ability

    :?abilityId = "voidweaver"
      result = result & isSummoned(abilityId) &
      ^canUnmakeVoidweaver()
    :?abilityId = "cinderwisp"
      result = result & isSummoned(abilityId)

    :?abilityId = "wand_stone"
      result = result & armor >= s.wand_stone_armor &
      ^foe.count > 1
    :?abilityId = "wand_poison"
      result = result & armor >= s.wand_poison_armor
    :?abilityId = "wand_vigor"
      result = result & armor >= s.wand_vigor_armor
    :?abilityId = "wand_aether"
      result = result & armor >= s.wand_aether_armor
    :?abilityId = "wand_fire"
      result = result & armor >= s.wand_fire_armor
    :?abilityId = "wand_ice"
      result = result & armor >= s.wand_ice_armor

    :?abilityId = "staff_stone"
      result = result & armor >= s.staff_stone_armor
    :?abilityId = "staff_poison"
      result = result & armor >= s.staff_poison_armor
    :?abilityId = "staff_vigor"
      result = result & armor >= s.staff_vigor_armor
    :?abilityId = "staff_aether"
      result = result & armor >= s.staff_aether_armor
    :?abilityId = "staff_fire"
      result = result & armor >= s.staff_fire_armor
    :?abilityId = "staff_ice"
      result = result & armor >= s.staff_ice_armor

  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility\nCAUSE: unknown <abilityId>:\n\n" + abilityId, false)
    loc.Pause()

  return result

/* Activates a two-handed item's ability.
ACCEPTS RENAMED WEAPONS!

Valid itemName values:
- blade >> Blade of the Fallen God
- arm >> Skeleton Arm
- bardiche
- heavy + hammer >> Heavy Hammer
- quarterstaff
- staff + <element> + hidden >> Hidden staves */
func useAbility_TH(itemName)
  equip @itemName@

  ?itemName = "blade"         | item.right = "blade"        |
  ^itemName = "arm"           | item.right = "arm"          |
  ^itemName = "bardiche"      | item.right = "bardiche"     |
  ^itemName = "heavy_hammer"  | item.right = "heavy_hammer" |
  ^itemName = "quarterstaff"  | item.right = "quarterstaff" |
  ^((itemName = "staff"       | item.right = "staff")     &
  ^ (itemName = "hidden"      | item.right = "hidden")    &
  ^  (itemName = "stone"      | item.right = "stone"        |
  ^   itemName = "poison"     | item.right = "poison"       |
  ^   itemName = "vigor"      | item.right = "vigor"        |
  ^   itemName = "aether"     | item.right = "aether"       |
  ^   itemName = "fire"       | item.right = "fire"         |
  ^   itemName = "ice"        | item.right = "ice"))
    activate R
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_TH\nCAUSE: <itemName> unknown or failed to equip:\n\n" + itemName, false)

    >`1,7,#magenta,
    ^itemName#=#@itemName@\n
    ^R#=#@item.right@

/* Activates a one-handed item's ability.

Valid itemName values:
- hatchet
- mask >> Cultist Mask
- <element> + talisman >> Talismans
- wand <element> + hidden >> Hidden wands */
func useAbility_OH(itemName, hand)
  ?itemName = "mask"        |
  ^itemName = "hatchet"     |
  ^((itemName = "talisman"    |
  ^ (itemName = "wand"        &
  ^  itemName = "hidden"))      &
  ^   (itemName = "stone"       |
  ^    itemName = "poison"      |
  ^    itemName = "vigor"       |
  ^    itemName = "aether"      |
  ^    itemName = "fire"        |
  ^    itemName = "ice")          )
    ?itemName = "talisman" & ai.walking &
    ^foe.distance > s.getRange("triskelion") &
    ^(hand = "r" | hand = "right")
      equipL triskelion

    ?itemName = "hatchet" | itemName = "mask"
      equipR @itemName@
      activate R
    
    :?hand = "l" | hand = "left"
      equipL @itemName@
      activate L
    :?hand = "r" | hand = "right"
      equipR @itemName@
      activate R
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_OH\nCAUSE: unknown <hand>:\n\n" + hand, false)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_T\nCAUSE: unknown <itemName>:\n\n" + itemName, false)
    loc.Pause()

/* Returns true if a given item is equipped. */
func isEquipped(itemName)
  return item.left = itemName | item.right = itemName
/* Returns true if an attack is being casted. */ 
func isCasting(itemName)
  return
  ^(item.left = itemName & item.left.state = 2) |
  ^(item.right = itemName & item.right.state = 2)
/* Returns true if a foe has been defeated. */
func isDead()
  return foe.state = 4 | foe.state = -1 // foe death states

// ......... Double Screen (DS) ......... //

func isScreen_DS_Target(itemName)
  ?itemName = "smite" | itemName = "bfg" | itemName = "blade"
    return screen.i = smiteScreen_Target
  :?itemName = "mask" | itemName = "feeble"
    return screen.i = maskScreen_Target
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS_Target\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

    return false
func isScreen_DS_Max(itemName)
  ?itemName = "smite" | itemName = "bfg" | itemName = "blade"
    return smiteScreen_Target = smiteScreen_Max
  :?itemName = "mask" | itemName = "feeble"
    return maskScreen_Target = maskScreen_Max
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS_Max\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

    return false

func screen_DS_Change(itemName)
  ?loc.loop & totaltime = 1 & !isScreen_DS_Max(itemName)
    ?itemName = "smite" | itemName = "bfg" |
    ^itemName = "blade"
      smiteScreen_Target++
    :?itemName = "mask" | itemName = "feeble"
      maskScreen_Target++
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: screen_DS_Change\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

/* Checks if a weapon ability can be used in 2 screens of distance, according to a certain screen index. */
func canUseAbility_DS(itemName)
  var result = false

  ?itemName = "blade" |
  ^itemName = "mask"
    result = canUseAbility(itemName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

  ?result
    result = result & isScreen_DS_Target(itemName)

  return result
func useAbility_DS(itemName)
  ?itemName = "blade" |
  ^itemName = "mask"
    ?slideCount = 0
      screen.Next()
      slideCount = 20

    :?slideCount > 0
      slideCount--

      ?slideCount = 0
        useAbility_TH(itemName)
        screen.ResetOffset()
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

// ..... Talisman / Summon specific ..... //

func isSummoned(summonName)
  return summon.GetId() = summonName
/* Checks if a summon can be invoked by its respective talisman. */
func canSummon(summonName)
  var result = canUseAbility(summonName)

  ?result
    ?summonName = "stone_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & !isSummoned("") */
    :?summonName = "poison_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & !isSummoned("") */
    :?summonName = "vigor_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & !isSummoned("") */
    :?summonName = "aether_talisman"
      result = result & !isSummoned("voidweaver")
    :?summonName = "fire_talisman"
      result = result & !isSummoned("cinderwisp")
    :?summonName = "ice_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & !isSummoned("") */
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canSummon\nCAUSE: unknown <summonName>: " + summonName, false)

      result = false

  return result
/* Checks if a summon can be hidden by its respective talisman. */
func canHide(summonName)
  var result = canUseAbility(summonName)

  ?result
    ?summonName = "stone_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & isSummoned("") */
    :?summonName = "poison_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & isSummoned("") */
    :?summonName = "vigor_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & isSummoned("") */
    :?summonName = "aether_talisman"
      result = result & isSummoned("voidweaver")
    :?summonName = "fire_talisman"
      result = result & isSummoned("cinderwisp")
    :?summonName = "ice_talisman"
      result = false // TO DO: uncomment logic when this talisman is added.
      /* result = result & isSummoned("") */
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canHide\nCAUSE: unknown <summonName>: " + summonName, false)

      result = false

  return result

/* Activates a summon's "Devour" ability.

Valid summonName values:
- voidweaver
- cinderwisp */
func devour(summonName)
  ?summonName = "voidweaver" |
  ^summonName = "cinderwisp"
    ?isSummoned(summonName)
      ?summonName = "voidweaver"
        activate voidweaver
      : // summonName = "cinderwisp"
        activate cinderwisp
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: " + @summonName@ + " isn't summoned", false)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: unknown <summonName>:\n\n" + summonName, false)


/* Returns true if the voidweaver's ability is
effective against the current foes the player is
facing. */
func canUnmakeVoidweaver()
  return !(
  ^ (foe = "boss") | // bosses are immune to unmake
  ^ encounter.eliteMod = "tenacious" | ( // tenacious can't be debuffed
  ^   encounter.eliteMod = "monarch" &
  ^   foe.count = 1) // monarch foes can't be unmade
  ^)

/* Checks if the cinderwisp's "devour" ability damage
will kill the foe.

cinderwispDmg: damage dealt by cinderwisp for each
              ignition.
margin: number representing a health margin to add
        to the remaining foe's health. This is
        necessary because the ability has a cast time
        that will alter the estimations done here.
        Send 0 if you don't want to use a margin. */
func canKillCinderwisp(cinderwispDmg, margin)
  var result = false
  var debuffCount = s.getEffectStat("foe","debuff","ignition","count") // amount of debuffs stacked

  ?canUseAbility("cinderwisp") & debuffCount
    result = s.getTotalHP("foe") <= (debuffCount * cinderwispDmg) + margin

  return result
/* Checks if the maximum amount of ignition debuffs have been
applied to a certain foe.

ignitions_cap: maximum number of ignition debuffs
               that can be applied. Varies on upgrade level or
               boosted stat. */
func isCinderwispCap(ignitions_cap)
  return foe.debuffs.string = ignitions_cap

// ............... Potions .............. //

/* Checks if a certain potion can be brewed.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func canBrewPotion(potionName)
  var result = loc.begin & item.potion ! potionName

  ?potionName = "strength"
    result = result & res.stone >= 20
  :?potionName = "experience"
    result = result & res.wood >= 20
  :?potionName = "healing"
    result = result & res.tar >= 20
  :?potionName = "lightning"
    result = result & res.bronze >= 20
  :?potionName = "vampiric"
    result = result & res.tar >= 10 & res.bronze >= 10
  :?potionName = "lucky"
    result = result & res.stone >= 10 & res.bronze >= 10
  :?potionName = "berserk"
    result = result & res.wood >= 10 & res.bronze >= 10
  :?potionName = "cleansing"
    result = result & res.wood >= 10 & res.tar >= 10
  :?potionName = "defensive"
    result = result & res.stone >= 10 & res.tar >= 10
  :?potionName = "invisibility"
    result = result & res.wood >= 10 & res.stone >= 10

  :
    result = false

  return result
/* Brews a certain potion.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func brewPotion(potionName)
  ?potionName = "strength"
    brew stone
  :?potionName = "experience"
    brew wood
  :?potionName = "healing"
    brew tar
  :?potionName = "lightning"
    brew bronze
  :?potionName = "vampiric"
    brew tar + bronze
  :?potionName = "lucky"
    brew stone + bronze
  :?potionName = "berserk"
    brew wood + bronze
  :?potionName = "cleansing"
    brew wood + tar
  :?potionName = "defensive"
    brew stone + tar
  :?potionName = "invisibility"
    brew wood + stone
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: brewPotion\nCAUSE: unknown <potionName>: " + potionName)

func canUsePotion(potionName)
  return item.CanActivate() &
  ^item.potion ! "empty" &
  ^item.potion = potionName

// ........... Status effects ........... //

/* Returns foe's damage, accounting for
any damage-reduction debuffs applied.

weakenAmount = if applied, amount of damage
              deducted to the foe by the
              weapon you used for it.
feebleCount = if applied, amount of Feeble
              debuffs your Cultist Mask can
              apply.
***************** WARNING *****************
  Since these are variable, they can't be
  calculated, so they have to be provided
        for this function to work.
******************************************* */
func getFoeDamage(weakenAmount, feebleCount)
  var result = foe.damage
  var isWeakened = false
  var isFeebled = false

  ?foe.debuffs.string = "feeble" & !isWeakened
    result -= (2 * feebleCount)
    isWeakened = true
  ?foe.debuffs.string = "debuff_damage" & !isFeebled
    result -= weakenAmount
    isFeebled = true

  ?result < 0
    result = 0

  return result

/* Returns true if the foe is
vulnerable to Chill and if the
debuff isn't applied yet. */
func canApplyChill()
  return
  ^foe.debuffs.string ! "chill:6" &
  ^foe ! "immune_to_debuff_chill"
/* Returns true if the foe is
vulnerable to Weaken and if the
debuff isn't applied yet. */
func canApplyWeaken()
  return
  ^foe.debuffs.string ! "damage" &
  ^foe ! "immune_to_debuff_damage"
/* Returns true if the foe is
vulnerable to Burn and if the
debuff isn't applied yet. */
func canApplyBurn()
  return
  ^foe.debuffs.string ! "dot" &
  ^foe ! "immune_to_debuff_dot"

/* checks if the foe is vulnerable
to at least one of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canDebuffAny()
  return
  ^canApplyChill() |
  ^canApplyWeaken() |
  ^canApplyBurn()
/* checks if the foe is vulnerable
to ALL of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canDebuffAll()
  return
  ^foe ! "immune_to_debuff_chill" &
  ^foe ! "immune_to_debuff_damage" &
  ^foe ! "immune_to_debuff_dot"

// ......... Damage min-maxing .......... //

func doMoondial(weapon1, weapon2)
  var moondialFrame = null
  
  ?moondialMode = 0 // Normal moondialing
    moondialTimer++
    moondialFrame = moondialTimer % 3

    ?moondialFrame = 1
      equipL moon
      equipR @weapon1@
    :?moondialFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?moondialMode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moondialTimer++
    moondialFrame = moondialTimer % 4

    ?moondialFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moondialFrame = 2
      equipL moon
      equipR @weapon1@
    :?moondialFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moondialFrame = 4
      equipL moon
      equipR @weapon2@

  :?moondialMode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?moondialMode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    equipL moon
    equipR @weapon1@

/* Moondialing variant, aka Bursting.
Requires a minimum of 2 swords to cycle through.
Works with an unlimited number of swords

weaponsArr: array with all the swords to use. Every sword must have a +21 enchanted boosting its stat attack speed.

Usage example:
  doBursting([sword fire *max +21,
              sword ice *max +21,
              sword poison *max +21,
              sword vigor *max +21,
              sword aether *max +21]) */
func doBursting(weaponsArr)
  var n = weaponsArr.Count()

  ?n >= 2
    ?burstingTimer >= n - 1 // cooldown frame
      // cycle trough every weapon:
      equipL @weaponsArr[burstingCdTimer]@
      equipR @weaponsArr[burstingCdTimer + 1]@
      burstingCdTimer+= 2 // increment burstingCdTimer twice each loop

      ?burstingCdTimer >= n - 2
        burstingTimer = 0 // reset timer
        burstingCdTimer = 0

    : // bursting frame (different weapon every frame)
      equipL moon
      equipR @weaponsArr[burstingTimer]@
      burstingTimer++

  :
    u.showStrCtr(0,30,#red,"ERROR:\nFILE: Combat\nFUNCTION: doBursting\nCAUSE: <weaponsArr> was too small (had " + n + " weapons", false)

/* AAC = Attack Animation Cancelling
Widely used trick to enable a
massive attack speed boost*/
func doAAC(itemLeft, itemRight)
  ?item.left.state = 3
    equipL @itemLeft@
    equipL @item.left@

  ?item.right.state = 3
    equipR @itemRight@
    equip @item.right@ // equip works for two-handed items as well

// ............... Others ............... //

func isDashingRange()
  return s.dash_range_min <= foe.distance &
  ^      foe.distance <= s.dash_range_max


//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀▄ END OF "Combat" ▀▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //