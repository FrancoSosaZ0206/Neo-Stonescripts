//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀ START OF "Combat" ▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //


/* // ///////////// FILE INFO //////////////// //

Combat functions library
Made by IronHawk (Tom Crow)

. ................ Description ................ .

  This library provides some game-related
  functions to make the task of doing a
  farming script easier.

. ................. Importing ................. .

  var c = new Combat

. .................... Tip .................... .

  If you want to use the variables here,
  put c.Init() at the top of your script.

. ................... Usage ................... .

  ?c.canUseAbility("blade")
    c.useAbility_TH("blade")

. ...................................... .

Enjoy! */


// ///////////////// IMPORTS ///////////////// //

var u = import My/Lib/Utilities
var s = import My/Lib/Stats


// //////////////// VARIABLES //////////////// //

// Status

var midhp
var lowhp
var hihp


// Function-related

var smiteScreen_Target = -1
var smiteScreen_Max = -1
var maskScreen_Target = -1
var maskScreen_Max = -1

var slideCount = 0 // counter to give screen.Next() time to slide in _DS functions.

var moondialMode = -1
var moondialTimer = 0
var burstingTimer = 0
var burstingCdTimer = 0

var item_TH_IDs = [ // two-handed item IDs
^   "blade",
^   "arm",

^   "bardiche",
^   "heavy_hammer",
^   "quarterstaff",

^   "staff_hidden_poison",
^   "staff_hidden_vigor",
^   "staff_hidden_aether",
^   "staff_hidden_fire",
^   "staff_hidden_ice",
^   "staff_hidden_stone"
^]

var item_OH_IDs = [ // one-handed item IDs
^   "mask",
^   "hatchet",

// ^   "stone_talisman",
// ^   "poison_talisman",
// ^   "vigor_talisman",
^   "aether_talisman",
^   "fire_talisman",
// ^   "ice_talisman",

^   "wand_hidden_poison",
^   "wand_hidden_vigor",
^   "wand_hidden_aether",
^   "wand_hidden_fire",
^   "wand_hidden_ice",
^   "wand_hidden_stone"
^]

var item_DS_IDs = [ // IDs of items' abilities that can be used in 2 screens
^   "blade",
^   "mask"
^]


// Others

var permapotSetup = loc.stars > 10 // only true from yellow onwards


// //////////////// FUNCTIONS //////////////// //

func Init()
  midhp = maxhp / 2
  lowhp = maxhp / 3
  hihp = (4 * maxhp) / 5

  ?buffs.string = "⊙" // berserk potion
    moondialMode = 2
  :
    moondialMode = 0

  ?loc.begin
    smiteScreen_Target = 1
  :?loc.loop
    permapotSetup = false

// ............... GLOBAL ............... //

/* Returns true if a given weapon's special ability can be activated.

Valid abilityId values:
- blade >> Blade of the Fallen God
- mask >> Cultist Mask
- arm >> Skeleton Arm (REQUIRES GAINING AT LEAST 1 PICK-POCKET BUFF)
- bash >> Bashing Shield
- dash >> Dashing Shield
- bardiche
- heavy_hammer
- quarterstaff
- mind >> Mindstone
- hatchet
- voidweaver >> Aether Talisman's summon
- cinderwisp >> Fire Talisman's summon
- staff + <name>, staff + <element> >> Hidden staves
- wand + <name>, wand + <element> >> Hidden wands
- <element>_talisman >> Talismans */
func canUseAbility(abilityID)
  var result = false

  ?cooldown_IDs.Contains(abilityID)
    // Valid ID
    result = item.CanActivate() &
    ^item.GetCooldown(abilityId) <= 0

    ?abilityId = "bash" | abilityId = "dash"
      result = result & s.inRange("dash") & !ai.idle
    :?abilityId = "arm"
      result = result & item.CanActivate("arm") &
      ^s.inRange("arm") &
      ^buffs.string = "pick_pocket"

    :?abilityId = "hatchet"
      result = (result & loc = "deadwood_valley" &
      ^         s.inRange(abilityId)) |
      ^isCasting(abilityId) // won't get interrupted

    :?abilityId = "bardiche" |
    ^abilityId = "heavy_hammer"
      result = (result & s.inRange(abilityId + " ability")) |
      ^isCasting(abilityId) // won't get interrupted

    :?abilityId = "quarterstaff" |
    ^abilityId = "talisman" // interruptible abilities
      result = result | isCasting(abilityId) // make sure not to change it while casting the ability

    :?s.getSummon(abilityId) ! -1
      result = result & isSummoned(abilityId)

      ?abilityId = "voidweaver"
        result = result & canUnmakeVoidweaver()
      :?abilityId = "cinderwisp"
        result = result & foe.debuffs.string = "ignition"

    :?abilityId = "_hidden_"
      result = result & armor >= s.getArmor(abilityID)

      ?abilityId = "wand_poison"
        result = result &
        ^!(foe = "immune_to_debuff_damage" |
        ^  encounter.eliteMod = "tenacious")
      :?abilityId = "wand_ice"
        result = result &
        ^!(foe = "immune_to_stun" |
        ^  encounter.eliteMod = "tenacious")
      : // abilityId = "wand_stone"
        result = result & foe.count > 1 &
        ^item.CanActivate("wand_stone")
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility\nCAUSE: unknown <abilityId>:\n\n" + abilityId, false)
    loc.Pause()

  return result

/* Activates a two-handed item's ability.
ACCEPTS RENAMED WEAPONS!

Valid itemName values:
- blade >> Blade of the Fallen God
- arm >> Skeleton Arm
- bardiche
- heavy + hammer >> Heavy Hammer
- quarterstaff
- staff + <element> + hidden >> Hidden staves */
func useAbility_TH(itemName)
  equip @itemName@

  ?item_TH_IDs.Contains(itemName) |
  ^item_TH_IDs.Contains(item.right)
    activate R
  :
    ?!item_TH_IDs.Contains(itemName)
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_TH\nCAUSE: <itemName> unknown:\n\n" + itemName, false)
    : // !item_TH_IDs.Contains(item.right)
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_TH\nCAUSE: " + itemName + " failed to equip:\n\n" + item.right, false)
/* Activates a one-handed item's ability.

Valid itemName values:
- hatchet
- mask >> Cultist Mask
- <element> + talisman >> Talismans
- wand <element> + hidden >> Hidden wands */
func useAbility_OH(itemName, hand)
  ?item_OH_IDs.Contains(itemName)
    // talismans equipment logic
    ?itemName = "talisman"
      ?ai.walking & !s.inRange("triskelion") &
      ^(hand = "r" | hand = "right")
        equipL triskelion

      :?isDashingRange()
        ?canUseAbility("bash")
          equipR bash
        :?canUseAbility("bash")
          equipR dash

    // special one-handed weapons equipment logic
    :?itemName = "hatchet" | itemName = "mask"
      equipR @itemName@
      activate R
    
    // normal equipment logic
    :?hand = "l" | hand = "left"
      equipL @itemName@
      activate L
    :?hand = "r" | hand = "right"
      equipR @itemName@
      activate R
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_OH\nCAUSE: unknown <hand>:\n\n" + hand, false)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_T\nCAUSE: unknown <itemName>:\n\n" + itemName, false)
    loc.Pause()

/* Returns true if a given item is equipped. */
func isEquipped(itemName)
  return item.left = itemName | item.right = itemName
/* Returns true if an attack is being casted. */ 
func isCasting(itemName)
  return
  ^(item.left = itemName & item.left.state = 2) |
  ^(item.right = itemName & item.right.state = 2)
/* Returns true if a foe has been defeated. */
func isDead()
  return foe.state = 4 | foe.state = -1 // foe death states

// ......... Double Screen (DS) ......... //

func isScreen_DS_Target(itemName)
  ?item_DS_IDs.Contains(itemName)
    ?itemName = "blade"
      return screen.i = smiteScreen_Target
    : // itemName = "mask"
      return screen.i = maskScreen_Target
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS_Target\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

    return false
func isScreen_DS_Max(itemName)
  ?item_DS_IDs.Contains(itemName)
    ?itemName = "blade"
      return smiteScreen_Target = smiteScreen_Max
    : // itemName = "mask"
      return maskScreen_Target = maskScreen_Max
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: isScreen_DS_Max\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

    return false
func screen_DS_Change(itemName)
  ?loc.loop & totaltime = 1 & !isScreen_DS_Max(itemName)
    ?item_DS_IDs.Contains(itemName)
      ?itemName = "blade"
        smiteScreen_Target++
      : // itemName = "mask"
        maskScreen_Target++
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: screen_DS_Change\nCAUSE: unknown <itemName>:\n\n" + itemName, false)

/* Checks if a weapon ability can be used in 2 screens
of distance, according to a certain screen index. */
func canUseAbility_DS(itemName)
  ?item_DS_IDs.Contains(itemName)
    return canUseAbility(itemName) &
    ^isScreen_DS_Target(itemName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canUseAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

    return false
func useAbility_DS(itemName)
  ?item_DS_IDs.Contains(itemName)
    ?slideCount = 0
      screen.Next()
      slideCount = 20

    :?slideCount > 0
      slideCount--

      ?slideCount = 0
        useAbility_TH(itemName)
        screen.ResetOffset()
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: useAbility_DS\nCAUSE: unknown <itemName>: " + itemName, false)

// ..... Talisman / Summon specific ..... //

func isSummoned(summonName)
  return summon.GetId() = summonName
/* Checks if a summon can be invoked by its respective talisman. */
func canSummon(summonName)
  var result = s.getTalisman(summonName)

  ?result
    return canUseAbility(result) & !isSummoned(summonName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canSummon\nCAUSE: unknown <summonName>: " + summonName, false)

  return result
/* Checks if a summon can be hidden by its respective talisman. */
func canHide(summonName)
  var result = s.getTalisman(summonName)

  ?result
    return canUseAbility(result) & isSummoned(summonName)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: canHide\nCAUSE: unknown <summonName>: " + summonName, false)

  return result

/* Activates a summon's "Devour" ability.

Valid summonName values:
- voidweaver
- cinderwisp */
func devour(summonName)
  ?s.talisman_table.Contains(summonName)
    ?isSummoned(summonName)
      /*?summonName = ""
        activate */
      /*:?summonName = ""
        activate */
      ?summonName = "voidweaver"
        activate voidweaver
      :?summonName = "cinderwisp"
        activate cinderwisp
      /*:?summonName = ""
        activate */
      /*: // summonName = ""
        activate */
    :
      u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: " + @summonName@ + " isn't summoned", false)
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: devour\nCAUSE: unknown <summonName>:\n\n" + summonName, false)


/* Checks if the cinderwisp's "devour" ability damage
will kill the foe.

cinderwispDmg: damage dealt by cinderwisp for each
              ignition.
margin: number representing a health margin to add
        to the remaining foe's health. This is
        necessary because the ability has a cast time
        that will alter the estimations done here.
        Send 0 if you don't want to use a margin. */
func canKillCinderwisp(cinderwispDmg, margin)
  var result = false
  var debuffCount = s.getEffectStat("foe","debuff","ignition","count") // amount of debuffs stacked

  ?canUseAbility("cinderwisp") & debuffCount
    result = s.getTotalHP("foe") <= (debuffCount * cinderwispDmg) + margin

  return result
/* Checks if the maximum amount of ignition debuffs have been
applied to a certain foe.

ignitions_cap: maximum number of ignition debuffs
               that can be applied. Varies on upgrade level or
               boosted stat. */
func isCinderwispCap(ignitions_cap)
  return foe.debuffs.string = ignitions_cap

// ............... Potions .............. //

/* Checks if a certain potion can be brewed.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func canBrewPotion(potionName)
  var result = loc.begin & item.potion ! potionName

  ?potionName = "strength"
    result = result & res.stone >= 20
  :?potionName = "experience"
    result = result & res.wood >= 20
  :?potionName = "healing"
    result = result & res.tar >= 20
  :?potionName = "lightning"
    result = result & res.bronze >= 20
  :?potionName = "vampiric"
    result = result & res.tar >= 10 & res.bronze >= 10
  :?potionName = "lucky"
    result = result & res.stone >= 10 & res.bronze >= 10
  :?potionName = "berserk"
    result = result & res.wood >= 10 & res.bronze >= 10
  :?potionName = "cleansing"
    result = result & res.wood >= 10 & res.tar >= 10
  :?potionName = "defensive"
    result = result & res.stone >= 10 & res.tar >= 10
  :?potionName = "invisibility"
    result = result & res.wood >= 10 & res.stone >= 10

  :
    result = false

  return result
/* Brews a certain potion.
**********************************************
REQUISITE: POTION NAMES MUST BE ALL LOWERCASE.
********************************************** */
func brewPotion(potionName)
  ?potionName = "strength"
    brew stone
  :?potionName = "experience"
    brew wood
  :?potionName = "healing"
    brew tar
  :?potionName = "lightning"
    brew bronze
  :?potionName = "vampiric"
    brew tar + bronze
  :?potionName = "lucky"
    brew stone + bronze
  :?potionName = "berserk"
    brew wood + bronze
  :?potionName = "cleansing"
    brew wood + tar
  :?potionName = "defensive"
    brew stone + tar
  :?potionName = "invisibility"
    brew wood + stone
  :
    u.showStrCtr(0,30,#red,"ERROR\nFILE: Combat\nFUNCTION: brewPotion\nCAUSE: unknown <potionName>: " + potionName)

func canUsePotion(potionName)
  return item.CanActivate() &
  ^item.potion ! "empty" &
  ^item.potion = potionName

// ........... Status effects ........... //

/* Returns foe's damage, accounting for
any damage-reduction debuffs applied.

weakenAmount = if applied, amount of damage
              deducted to the foe by the
              weapon you used for it.
feebleCount = if applied, amount of Feeble
              debuffs your Cultist Mask can
              apply.
***************** WARNING *****************
  Since these are variable, they can't be
  calculated, so they have to be provided
        for this function to work.
******************************************* */
func getFoeDamage(weakenAmount, feebleCount)
  var result = foe.damage
  var isWeakened = false
  var isFeebled = false

  ?foe.debuffs.string = "feeble" & !isWeakened
    result -= (2 * feebleCount)
    isWeakened = true
  ?foe.debuffs.string = "debuff_damage" & !isFeebled
    result -= weakenAmount
    isFeebled = true

  ?result < 0
    result = 0

  return result

/* Returns true if the current foes the player is
facing can be unmade. */
func canDebuff()
  return !(
  ^ foe.buffs.string = "buff_tenacious" // tenacious foes can't be debuffed
  ^)
/* Returns true if the current foes the player is
facing can be unmade. */
func canUnmake()
  return !(
  ^ foe = "boss" | // bosses are immune to unmake
  ^ foe = "monarch" | // monarch foes can't be unmade
  ^ foe.buffs.string = "buff_tenacious" // tenacious foes can't be debuffed
  ^)

/* Returns true if the foe is
vulnerable to Chill and if the
debuff isn't applied yet. */
func canApplyChill()
  return canDebuff() &
  ^foe.debuffs.string ! "chill" &
  ^foe ! "immune_to_debuff_chill"
/* Returns true if the foe is
vulnerable to Chill and the debuff
stack isn't full yet. */
func canApplyChillFull()
  return canDebuff() &
  ^foe.debuffs.string ! "chill:6" &
  ^foe ! "immune_to_debuff_chill"
/* Returns true if the foe is
vulnerable to Weaken and if the
debuff isn't applied yet. */
func canApplyWeaken()
  return canDebuff() &
  ^foe.debuffs.string ! "damage" &
  ^foe ! "immune_to_debuff_damage"
/* Returns true if the foe is
vulnerable to Burn and if the
debuff isn't applied yet. */
func canApplyBurn()
  return canDebuff() &
  ^foe.debuffs.string ! "dot" &
  ^foe ! "immune_to_debuff_dot"

/* checks if the foe is vulnerable
to at least one of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canApplyAny()
  return
  ^canApplyChill() |
  ^canApplyWeaken() |
  ^canApplyBurn()
/* checks if the foe is vulnerable
to ALL of the following
typical debuffs:
- Chill (attack and movement speed reduction)
- Weaken (damage reduction)
- Burn (damage over time) */
func canApplyAll()
  return canDebuff()  &
  ^canApplyChill()    &
  ^canApplyWeaken()   &
  ^canApplyBurn()

// ......... Damage min-maxing .......... //

func doMoondial(weapon1, weapon2)
  var moondialFrame = null
  
  ?moondialMode = 0 // Normal moondialing
    moondialTimer++
    moondialFrame = moondialTimer % 3

    ?moondialFrame = 1
      equipL moon
      equipR @weapon1@
    :?moondialFrame = 2
      equipL moon
      equipR @weapon2@
    :
      equipL @weapon1@
      equipR @weapon2@

  :?moondialMode = 1
    /* Berserk Moondialing (For non-speed enchanted *max
    swords) */
    moondialTimer++
    moondialFrame = moondialTimer % 4

    ?moondialFrame = 1
      equipL @weapon2@ // on cooldown
      equipR @weapon1@
    :?moondialFrame = 2
      equipL moon
      equipR @weapon1@
    :?moondialFrame = 3
      equipL @weapon1@ // on cooldown
      equipR @weapon2@
    :?moondialFrame = 4
      equipL moon
      equipR @weapon2@

  :?moondialMode = 2
    /* Not moondialing, but useful to have here (speed
    enchant *max swords) */
    equipL @weapon2@
    equipR @weapon1@

  :?moondialMode = 3
    /* For when you have just 1 +21 sword (weapon2 can be
    anything, it will not be used) */
    equipL moon
    equipR @weapon1@

/* Moondialing variant, aka Bursting.
Requires a minimum of 2 swords to cycle through.
Works with an unlimited number of swords

weaponsArr: array with all the swords to use. Every sword must have a +21 enchanted boosting its stat attack speed.

Usage example:
  doBursting([sword fire *max +21,
              sword ice *max +21,
              sword poison *max +21,
              sword vigor *max +21,
              sword aether *max +21]) */
func doBursting(weaponsArr)
  var n = weaponsArr.Count()

  ?n >= 2
    ?burstingTimer >= n - 1 // cooldown frame
      // cycle trough every weapon:
      equipL @weaponsArr[burstingCdTimer]@
      equipR @weaponsArr[burstingCdTimer + 1]@
      burstingCdTimer+= 2 // increment burstingCdTimer twice each loop

      ?burstingCdTimer >= n - 2
        burstingTimer = 0 // reset timer
        burstingCdTimer = 0

    : // bursting frame (different weapon every frame)
      equipL moon
      equipR @weaponsArr[burstingTimer]@
      burstingTimer++

  :
    u.showStrCtr(0,30,#red,"ERROR:\nFILE: Combat\nFUNCTION: doBursting\nCAUSE: <weaponsArr> was too small (had " + n + " weapons", false)

/* AAC = Attack Animation Cancelling
Widely used trick to enable a
massive attack speed boost*/
func doAAC(itemLeft, itemRight)
  ?item.left.state = 3
    equipL @itemLeft@
    equipL @item.left@

  ?item.right.state = 3
    equipR @itemRight@
    equip @item.right@ // equip works for two-handed items as well

// ............... Others ............... //

func isDashingRange()
  return s.dash_range_min <= foe.distance &
  ^      foe.distance <= s.dash_range_max


//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀▄ END OF "Combat" ▀▄▀▄▀▄▀▄▀▄▀▄ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //