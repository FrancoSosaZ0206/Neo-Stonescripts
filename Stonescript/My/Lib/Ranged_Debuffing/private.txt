// Imports:

var log = import My/Lib/Error_Logging/public
var es = import My/Lib/Effect_Stats/public

// Variables:

var _FILE = "Ranged_Debuffing/private"

var trackerArr = []

// tracker dataset indexes
var _AFFIX        = 0
var _LAUNCH_COUNT = 1
var _STACK_COUNT  = 2

// Functions:

// private

/* Returns true only if all of the following conditions are met:
- affix is valid
- can attack
- can apply target debuff
- foe is vulnerable to projectiles
- foe is vulnerable to physical projectiles (if equipped weapon launches those).

Returns false otherwise. */
func canRangedDebuff(affix)
  ?!es.isValidAffix(affix)
    log.logError(_FILE,"canRangedDebuff","invalid <affix>: "+affix)
    return false
  :
    return ai.enabled & !ai.paused &
    ^es.canDebuff(es.toId(affix)) & foe ! "immune_to_ranged" &
    ^!(item.right = "crossbow" & foe = "immune_to_physical")

/* Returns an item's affix if it's ranged and is equipped in the target hand, null otherwise. */
func getItemAffix(hand)
  // validate left hand
  ?hand = "left" & item.left = "wand"
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.left = affix // if both item and affix match,
        return affix

  // validate right hand
  :?hand = "right" &
  ^ (item.right = "wand"   |
  ^  item.right = "staff"  |
  ^  item.right = "crossbow")
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.right = affix // if both item and affix match,
        return affix

  return null

/* Returns a tracker if found, null otherwise. Uses affix as search key. */
func getTracker(affix)
  ?!es.isValidAffix(affix)
    log.logError(_FILE, "getTracker",
    ^"invalid <affix>: "+affix)

    return null
  :
    for tracker : trackerArr
      ?tracker[_AFFIX] = affix
        return tracker

    return null

func updateTracker(affix, hand)
  var result = false
  var n = null
  n = trackerArr.Count()

  // if there are tracks,
  ?n > 0
    // find track
    for i = 0 .. n - 1
      var _affix = trackerArr[i][_AFFIX]

      // track found, update it
      ?affix = _affix
        // define shorter aliases to work with
        var _id        = es.toId(_affix)
        var stackCount = foe.debuffs.GetCount(_id)

        // Remove any finished trackers
        ?stackCount = es.toMaxStacks(_id) | es.isImmuneTo(_id)
          ?!trackerArr.RemoveAt(i)
            log.logError(_FILE, "updateTracker",
            ^"failed to remove finished tracker at index "+i)
            return // terminate function
          :
            result = true
            break // terminate loop

        // update stack count
        trackerArr[i][_STACK_COUNT] = stackCount

        // Track valid launches only from ranged/magic items
        // FIXME: add item.*.time = 0 for each hand
        // FIXME: if the above doesn't work, also try splitting each hand into a separate ? statement.
        ?hand = "left" & item.left.state = 3 |
        ^hand = "right" & item.right.state = 3
          trackerArr[i][_LAUNCH_COUNT] += 1 // increase launchCount

        result = true
        break // terminate loop

    ?!result
      trackerArr.Add([affix, 0, 0])
  :
    trackerArr.Add([affix, 0, 0])

// ------------------------------------------ //

// public

func track()
  // can't debuff or attack
  ?!es.isDebuffable() | !ai.enabled | ai.paused |
  ^foe.distance = 9999 | foe.distance > 22
    // clear the system if needed
    ?trackerArr.Count() > 0
      trackerArr.Clear()

  : // track each hand slot simultaneously:
    var affixL = getItemAffix("left")
    var affixR = getItemAffix("right")

    // Left hand:
    ?affixL
      updateTracker(affixL, "left")

    // Right hand:
    ?affixR
      updateTracker(affixR, "right")

func canTrack(debuffName)
  var result = false
  var tracker = null
  var _id = es.toId(debuffName)

  result = canRangedDebuff(es.toAffix(debuffName))

  ?result
    tracker = getTracker(es.toAffix(debuffName))
    ?tracker
      // only launch if not saturated
      result = (result & (
      ^tracker[_LAUNCH_COUNT] + tracker[_STACK_COUNT]
      ^ <
      ^es.toMaxStacks(_id)))

  return result

func toStr()
  var n = trackerArr.Count()
  var trackerStr = "Tracked Debuffs: "+n+"\n"

  ?n > 0
    for tracker : trackerArr
      var debName = es.toName(tracker[_AFFIX])
      var launchCount = tracker[_LAUNCH_COUNT]
      var stackCount = tracker[_STACK_COUNT]

      ?debName
        trackerStr += string.Format("{0} | L:{1} | S:{2}\n", 
        ^                 debName, launchCount, stackCount)

  return trackerStr
