// Imports:
var es = import My/Lib/Effect_Stats/public

// Variables:

var trackerArr = []

// tracker dataset indexes
var _AFFIX        = 0
var _LAUNCH_COUNT = 1
var _STACK_COUNT  = 2

// Functions:

// private

/* Returns an item's affix if it's ranged and is equipped in the target hand, null otherwise. */
func getItemAffix(hand)
  // validate left hand
  ?hand = "left" & item.left = "wand"
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.left = affix // if both item and affix match,
        return affix

  // validate right hand
  :?hand = "right" &
  ^ (item.right = "wand"   |
  ^  item.right = "staff"  |
  ^  item.right = "crossbow")
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.right = affix // if both item and affix match,
        return affix

  return null

/* Returns a tracker if found, null otherwise. Uses affix as search key. */
func getTracker(affix)
  ?!es.isValidAffix(affix)
    >c0,0,#ff0000,ERROR\n
    ^FILE: Ranged_Debuffing/private\n
    ^AT: getTracker\n
    ^CAUSE: invalid <affix>: @affix@.

    return null
  :
    for tracker : trackerArr
      ?tracker[_AFFIX] = affix
        return tracker

    return null

/* Returns true if the tracker was added, false if it already exists. */
func addTracker(affix)
  ?getTracker(affix) // already exists
    return false
  : // doesn't exist
    trackerArr.Add([affix, 0, 0])
    return true

/* Returns true if the debuff tracker exists and was removed,
false otherwise. */
func removeTracker(affix)
  ?!es.isValidAffix(affix)
    >c0,0,#ff0000,ERROR\n
    ^FILE: Ranged_Debuffing/private\n
    ^AT: removeTracker\n
    ^CAUSE: invalid <affix>: @affix@.

    return false
  : // valid affix, loop through the array and look for tracker to remove
    var n = trackerArr.Count()

    for i = 0 .. n - 1
      ?trackerArr[i][_AFFIX] = affix
        ?!trackerArr.RemoveAt(i)
          >c0,0,#ff0000,ERROR\n
          ^FILE: Ranged_Debuffing/private\n
          ^AT: removeTracker\n
          ^CAUSE: failed to remove tracker at index @i@/@n - 1@.

          return false
        :
          return true

    return false

// ------------------------------------------ //

// public

func track()
  // foe can't be debuffed
  ?!es.isDebuffable()
    // clear the system if needed
    ?trackerArr.Count() > 0
      trackerArr.Clear()

  : // add and track
    var affixL = getItemAffix("left")
    var affixR = getItemAffix("right")

    // add tracker based on item equipped in left hand
    ?affixL
      addTracker(affixL)

    // same in right hand, though only if it's different from the left one
    ?affixR & affixL ! affixR
      addTracker(affixR)

    // Process each tracker
    for tracker : trackerArr
      // update stack count
      tracker[_STACK_COUNT] = foe.debuffs.GetCount(
      ^                         es.toId(tracker[_AFFIX]))

      // define shorter aliases to work with
      var affix = tracker[_AFFIX]
      var launchCount = tracker[_LAUNCH_COUNT]
      var stackCount  = tracker[_STACK_COUNT]

      // Remove any finished trackers
      ?launchCount + stackCount >= es.toMaxStacks(es.toId(affix))
        removeTracker(affix)
        continue

      // Track valid launches only from ranged/magic items
      ?affix = affixL & item.left.state = 3
        tracker[_LAUNCH_COUNT] ++ // increase launchCount

      ?affix = affixR & item.right.state = 3
        tracker[_LAUNCH_COUNT] ++ // increase launchCount

func canDebuff(debuffName)
  var tracker = getTracker(es.toAffix(debuffName))

  ?tracker
    // only launch if not saturated
    return tracker[_LAUNCH_COUNT] + tracker[_STACK_COUNT] <
    ^es.toMaxStacks(es.toId(tracker[_AFFIX]))
  :
    /* not yet tracked, return true if:
      - targeted foe isn't immune to projectiles, and
      - can apply target debuff. */
    return foe ! "immune_to_ranged" &
    ^      es.canDebuff(es.toId(debuffName))

func monitor()
  var n = trackerArr.Count()
  >`1,7,#cyan,Tracked Debuffs: @n@
  for i = 0 .. n - 1
    var affix = es.toName(trackerArr[i][_AFFIX])
    var launchCount = trackerArr[i][_LAUNCH_COUNT]
    var stackCount = trackerArr[i][_STACK_COUNT]

    >`1,@8 + i@,#ccc,@affix@ | L:@launchCount@ | S:@stackCount@
