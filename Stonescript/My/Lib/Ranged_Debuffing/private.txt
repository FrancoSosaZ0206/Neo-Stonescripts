// Imports:

var log = import My/Lib/Error_Logging/public
var es = import My/Lib/Effect_Stats/public

// Variables:

var _FILE = "Ranged_Debuffing/private"

var trackerArr = []

// tracker dataset indexes
var _AFFIX        = 0
var _LAUNCH_COUNT = 1
var _STACK_COUNT  = 2

// Functions:

// private

/* Returns true only if all of the following conditions are met:
- affix is valid
- can attack
- can apply target debuff
- foe is vulnerable to projectiles
- foe is vulnerable to physical projectiles (if equipped weapon launches those).

Returns false otherwise. */
func canRangedDebuff(affix)
  ?!es.isValidAffix(affix)
    log.logError(_FILE,"canRangedDebuff","invalid <affix>: "+affix)
    return false
  :
    return ai.enabled & !ai.paused &
    ^es.canDebuff(es.toId(affix)) & foe ! "immune_to_ranged" &
    ^!(item.right = "crossbow" & foe = "immune_to_physical")

/* Returns an item's affix if it's ranged and is equipped in the target hand, null otherwise. */
func getItemAffix(hand)
  // validate left hand
  ?hand = "left" & item.left = "wand"
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.left = affix // if both item and affix match,
        return affix

  // validate right hand
  :?hand = "right" &
  ^ (item.right = "wand"   |
  ^  item.right = "staff"  |
  ^  item.right = "crossbow")
    for affix : es.listAffixes() // if match, validate affix
      ?affix & item.right = affix // if both item and affix match,
        return affix

  return null

/* Returns a tracker if found, null otherwise. Uses affix as search key. */
func getTracker(affix)
  ?!es.isValidAffix(affix)
    log.logError(_FILE, "getTracker",
    ^"invalid <affix>: "+affix)

    return null
  :
    for tracker : trackerArr
      ?tracker[_AFFIX] = affix
        return tracker

    return null

/* Returns true if the tracker was added, false if it already exists. */
func addTracker(affix)
  var result = canRangedDebuff(affix)

  ?result & !getTracker(affix) // does not exist
    trackerArr.Add([affix, 0, 0])
    result = true

  return result

/* Returns true if the debuff tracker exists and was removed,
false otherwise. */
func removeTracker(affix)
  ?!es.isValidAffix(affix)
    log.logError(_FILE, "removeTracker",
    ^"invalid <affix>: "+affix)

    return false
  : // valid affix, loop through the array and look for tracker to remove
    var n = trackerArr.Count()

    for i = 0 .. n - 1
      ?trackerArr[i][_AFFIX] = affix
        ?!trackerArr.RemoveAt(i)
          log.logError(_FILE, "removeTracker",
          ^"failed to remove tracker at index "+i+"/"+n - 1)

          return false
        :
          return true

    return false

// ------------------------------------------ //

// public

func track()
  // foe can't be debuffed
  ?!es.isDebuffable() | !ai.enabled | ai.paused
    // clear the system if needed
    ?trackerArr.Count() > 0
      trackerArr.Clear()

  : // add and track
    var affixL = getItemAffix("left")
    var affixR = getItemAffix("right")

    // add tracker based on item equipped in left hand
    ?affixL
      addTracker(affixL)

    // same in right hand, though only if it's different from the left one
    ?affixR & affixL ! affixR
      addTracker(affixR)

    ?trackerArr.Count() > 0
      // Process each tracker
      for tracker : trackerArr
        var affix = tracker[_AFFIX]
        var _id = es.toId(affix)

        // update stack count
        tracker[_STACK_COUNT] = foe.debuffs.GetCount(_id)

        // define shorter aliases to work with
        var launchCount = tracker[_LAUNCH_COUNT]
        var stackCount  = tracker[_STACK_COUNT]

        // Remove any finished trackers
        ?stackCount = es.toMaxStacks(_id) | es.isImmuneTo(_id)
          removeTracker(affix)
          break

        // Track valid launches only from ranged/magic items
        ?affix = affixL & item.left.state = 3
          tracker[_LAUNCH_COUNT] += 1 // increase launchCount

        ?affix = affixR & item.right.state = 3
          tracker[_LAUNCH_COUNT] += 1 // increase launchCount

func canTrack(debuffName)
  var result = false
  var tracker = null
  var _id = es.toId(debuffName)

  result = canRangedDebuff(es.toAffix(debuffName))

  ?result
    tracker = getTracker(es.toAffix(debuffName))
    ?tracker
      // only launch if not saturated
      result = (result & (
      ^tracker[_LAUNCH_COUNT] + tracker[_STACK_COUNT]
      ^ <
      ^es.toMaxStacks(_id)))

  return result

func monitor()
  var n = trackerArr.Count()
  >`1,7,#cyan,Tracked Debuffs: @n@

  ?trackerArr.Count() > 0
    for i = 0 .. n - 1
      var affix = es.toName(trackerArr[i][_AFFIX])
      var launchCount = trackerArr[i][_LAUNCH_COUNT]
      var stackCount = trackerArr[i][_STACK_COUNT]

      >`1,@8 + i@,#magenta,@affix@ | L:@launchCount@ | S:@stackCount@
