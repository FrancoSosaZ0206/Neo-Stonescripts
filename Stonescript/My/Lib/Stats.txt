//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄ START OF "Stats" ▀▄▀▄▀▄▀▄▀ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //

// //////////////// IMPORTS ///////////////// //

var log = import My/Lib/Error_Logging/public
var u = import My/Lib/Utilities

// /////////////// VARIABLES //////////////// //

/* FIXME: refactor current map layout from 
per-property to per-item. */

var _FILE = "My/Lib/Stats"

// .................. IDs ................... //

/* TODO: implement & account for renamed items
var items = [ // all items with their names and stonescript IDs
^   "NAME"          , "STONESCRIPT ID"      , "STAR LEVEL"      , "ENCHANT LEVEL"       , "LOST"    , "COSMETIC"
^] */

var abilities = [ // ability cooldown IDs only
^   "blade"   , "mask"        , "arm",
^   "mind"    ,
^   "bash"    , "dash"        ,
^   "hatchet" , "shovel"      ,
^   "bardiche", "heavy_hammer", "quarterstaff",

// ^   "stone_talisman", "poison_talisman",
^   /* "vigor_talisman" ,*/ "aether_talisman",
^   "fire_talisman", // "ice_talisman",

// ^   "", "",
^   /* "",*/ "voidweaver",
^   "cinderwisp", // ^   "",

^   "wand_stone", "wand_poison",
^   "wand_vigor", "wand_aether",
^   "wand_fire" , "wand_ice"   ,

^   "staff_stone", "staff_poison",
^   "staff_vigor", "staff_aether",
^   "staff_fire" , "staff_ice"
^]

var talismans = [
// ^"poison_talisman" , "vigor_talisman",
^"aether_talisman", "fire_talisman"
// ^"ice_talisman", "stone_talisman"]
^]

var summons = [
// ^"", "",
^"voidweaver", "cinderwisp"
// ^   "", ""]
^]

var hiddenItems = [
// Hidden wands
^["wand_poison", "plague wand"   , 6 ],
^["wand_vigor" , "reset wand"    , 1 ],
^["wand_aether", "calamity wand" , 14],
^["wand_fire"  , "explosive wand", 4 ],
^["wand_ice"   , "frost wand"    , 3 ],
^["wand_stone" , "gravity wand"  , 0 ],

// Hidden staves
^["staff_poison", "berserker staff" , 8],
^["staff_vigor" , "prevention staff", 4],
^["staff_aether", "grasping staff"  , 2],
^["staff_fire"  , "infernal staff"  , 6],
^["staff_ice"   , "eternity staff"  , 1],
^["staff_stone" , "acrobatic staff" , 3]]

var _HI_ID    = 0
var _HI_NAME  = 1
var _HI_ARMOR = 2

// .......................................... //

var potions = [
^   "strength"        ,
^   "experience"      ,
^   "healing"         ,
^   "lightning"       ,
^   "vampiric"        ,
^   "lucky"           ,
^   "berserk"         ,
^   "cleansing"       ,
^   "defensive"       ,
^   "invisibility"
^]


// ................. Ranges ................. //

var ranges = [
^   "ID"                    , "RANGE",

^   "blade"                 , 11,
^   "arm"                   , 7,

^   "bardiche"              , 9,
^   "bardiche ability"      , 7,
^   "heavy_hammer"          , 7,
^   "heavy_hammer ability"  , 21,

// These count both for dashing and bashing shields:
^   "dash_min"              , 11,
^   "dash_max"              , 16,

^   "shovel"                , 2,
^   "hatchet"               , 5,
^   "grappling_hook"        , 13,

// soul stones (the mindstone can be used no matter the range)
^   "star"                  , 12,
^   "ki"                    , 18,
^   "experience"            , 18,
^   "triskelion"            , 10,
^   "fissure"               , 18,
^   "moon"                  , 18,

^   "sword"                 , 5,
^   "hammer"                , 5,
^   "quarterstaff"          , 5,
^   "big_sword"             , 6,
^   "wand"                  , 20,
^   "socketed_staff"        , 20,
^   "crossbow"              , 22,
^   "socketed_shield"       , 40  // Engaging range
^]

// ............. Hitbox & Splash ............ //

// index accesors:
var _HS_IDS     = 0
var _HS_HITBOX  = 1
var _HS_SPLASH  = 2
var _HS_WIELD   = 3
var _HS_PARITY  = 4
var _HS_RANGED  = 5

// map (hs = hitbox & splash):
//      IDS,    HITBOX, SPLASH, WIELD, PARITY, RANGED
var map_hs = [
^   ["bardiche"      , 13, 4 , false, false, false],
^   ["blade"         , 13, 4 , false, false, false],
^   ["arm"           , 10, 1 , false, false, false],
^   ["basic crossbow", 7 , 4 , true , false, true ],
^   ["heavy crossbow", 8 , 4 , false, false, true ],
^   ["heavy_hammer"  , 9 , 4 , false, false, false],
^   ["sword"         , 7 , 3 , true , true , false],
^   ["staff melee"   , 7 , 3 , false, true , false],
^   ["hammer"        , 7 , 3 , true , true , false],
^   ["big sword"     , 8 , 3 , true , true , false],
^   ["wand"          , 5 , 4 , true , false, true ],
^   ["torch"         , 5 , 4 , true , false, true ],
// ^   ["harmonic"      , 5 , 4 , false, false, // ???],
^   ["staff magic"   , 7 , 4 , false, false, true ],

// NOTE: this one doesn't change for right hand
^   ["runestone"     , 6 , 4 , true , false, true ],

^   ["grappling_hook", 1 , 4 , false, false, true ],
^   ["stone throw"   , 3 , 4 , true , false, true ],
^   ["punch"         , 5 , 4 , true , false, false],
^   ["kick"          , 5 , 4 , true , false, false],
^   ["hatchet"       , 8 , 4 , false, true , false],
^   ["shovel"        , 6 , 3 , false, true , false],
^   ["fissure"       , 63, 0 , true , true , true]
^]

/* NOTE: on _WIELD:
  false = dual
  true  = single */

/* NOTE: on _PARITY:
  false = odd
  true  = even */

// .............. Special stats ............. //

/* the added range that the
Grasping Staff's ability adds: */
var grasping_buff = 10
var grasping_cap = 22

// Berserker Staff's bonus damage (%) at +1.
var berserker_base = 10
var reset_base = 29.5
// Plague Wand's Weaken level table
var plague_table =
^[1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6]

// Mask
var mask_lvl_table = [
^[5, 6, 7, 8, 9, 10], // Feeble: damage
^[1, 2, 3, 4, 5, 6 ]  // Active: max stacks
^]
// damage reduction per feeble applied
var maskEffReduction = 2

// ............ Function-Related ............ //

var _berserkerLvl  = null
var _plagueLvl     = null
var _maskLvl       = null

// //////////////// FUNCTIONS /////////////// //

// ............. Status Effects ............. //

/* Returns a stat of an effect,
or null if there was an error.

Valid <source> values: "foe", "player"
Valid <effectType> values: "buff", "debuff"
Valid <effectId> values: same as in game.
  for more info, consult the Wiki: https://stonestoryrpg.miraheze.org/wiki/Status_Effects
Valid <statType> values:
  - "1", "symbol"
  - "2", "name", "id"
  - "3", "count", "stack"
  - "4", "time", "duration" */
func getEffectStat(source, effectType, effectId, statType)
  // Entry sanitization:
  source = string.ToLower(source)
  effectType = string.ToLower(effectType)
  effectId = string.ToLower(effectId)
  statType = string.ToLower(statType)

  var stat = null // the effect stat to return
  var fxStr = null // the full effects string

  ?source = "foe" & string.Equals(effectType, "buff")
    fxStr = foe.buffs.string
  :?source = "foe" & effectType = "debuff"
    fxStr = foe.debuffs.string

  :?source = "player" & string.Equals(effectType, "buff")
    fxStr = buffs.string
  :?source = "player" & effectType = "debuff"
    fxStr = debuffs.string

  :
    log.logError(_FILE,"getEffectStat",
    ^"unknown <source> or <effectType>: <"+
    ^source + ">, <" + effectType + ">")

  ?fxStr // there are active effects
    // all effects are separated by a "," char
    var fxArr = string.Split(fxStr, ",")

    for i = 0 .. fxArr.Count() - 1
      ?fxArr[i] = effectId // target effect is active
        var fxStats = string.Split(fxArr[i], ":")

        ?statType = "1" | statType = "symbol"
          stat = fxStats[0]
        :?statType = "2" | statType = "name" | statType = "id"
          stat = fxStats[1]
        :?statType = "3" | statType = "count" | statType = "stack"
          stat = int.Parse(fxStats[2]) // convert into an int to be able to operate with in conditionals.
        :?statType = "4" | statType = "time" | statType = "duration"
          stat = int.Parse(fxStats[3]) // convert into an int to be able to operate with in conditionals.

  return stat

/* Returns a string formatted like a table with
a given target's active effects and their stats.
Has a full and a slim version.

- Full version example: "
Foe debuffs table:

Symbol | Name | Count | Time
❄ | chill | 4 | 352
o | stun | 1 | 100
* | unstable | 1 | 12
"

- Slim version example: "
Player buffs table:

<sym> x<n>, <mm:ss f>
i x12, 00:05 24f
∞ x4, 00:07 12f
"

Valid <source> values: "foe", "player"
Valid <effectType> values: "buff", "debuff" */
func getEffectsTable(source, effectType, isSlim)
  // Entry sanitization:
  source = string.ToLower(source)
  effectType = string.ToLower(effectType)

  var fxStr = null
  var fxTable = null

  // entry validation
  ?!["foe","player"].Contains(source)
    log.logError(_FILE,"showEffectsTable",
    ^"unknown <source>: <" + source + ">")

  :?!["buff","debuff"].Contains(effectType)
    log.logError(_FILE,"showEffectsTable",
    ^"unknown <effectType>: <" +
    ^effectType + ">")

  :
    ?source = "foe"
      ?effectType = "debuff"
        fxStr = foe.debuffs.string
      :
        fxStr = foe.buffs.string

    :?source = "player"
      ?effectType = "debuff"
        fxStr = debuffs.string
      :
        fxStr = buffs.string

    ?fxStr // there are active effects
      /* Overview:
      1. split effects
      2. for each effect, split into an array with all its stats, and
        a. add it to the matrix, or
        b. for the slim version, add all except index 2 (the name).

      - Effects are separated by a "," char
      - Stats are separated by a ":" char */
      
      var fxArr = []
      fxTable = string.Format("{0} {1}s table:\n\n",
      ^           string.Capitalize(source),
      ^           string.Capitalize(effectType))

      ?!isSlim
        fxTable += "Symbol | Name | Count | Time\n"
      :
        fxTable += "<sym>x<n> <mm:ss f>\n"

      var fxArr = []
      fxArr = string.Split(fxStr, ",")
      var fxArrFormatted = []
      
      var n
      n = fxArr.Count() - 1

      for i = 0 .. n
        ?fxArr.Count() - 1 ! n
          break

        var fxStats = string.Split(fxArr[i], ":")
        var statsFormatted = null

        ?!isSlim
          statsFormatted = string.Join(" | ", fxStats)
        :
          statsFormatted =
          ^   string.Format("{0}x{1} {2}",
          ^   fxStats[0], // <sym>
          ^   int.Parse(fxStats[2]), // <n>
          ^   u.myFormatSpeedrun(
          ^     int.Parse(fxStats[3]))) // <t>

        ?i < n
          statsFormatted += "\n"

        fxArrFormatted.Add(statsFormatted)


        ?fxArr[i]
          >c-10,0,fxArr[@i@]: @fxArr[i]@
        /* ?fxStats[0]
          >c-10,1,fxStats[0]: @fxStats[0]@
        ?fxStats[1]
          >c-10,2,fxStats[1]: @fxStats[1]@
        ?fxStats[2]
          >c-10,3,fxStats[2]: @fxStats[2]@
        ?fxStats[3]
          >c-10,4,fxStats[3]: @fxStats[3]@
        ?statsFormatted
          >c-10,5,statsFormatted: @statsFormatted@
        ?fxArrFormatted[i]
          >c-10,6,fxArrFormatted[@i@]: @fxArrFormatted[i]@
        ?fxTable
          >c-10,7,fxTable: @fxTable@ */

        loc.Pause()

      fxTable += string.Join("\n", fxArrFormatted)

  return fxTable

/* Returns the sum of a given target's current
hp and armor. */
func getTotalHP(source)
  ?source = "foe"
    return foe.hp + foe.armor
  :?source = "player"
    return hp + armor
  :
    log.logError(_FILE,"getTotalHP",
    ^"unknown <source>: " + source)

    return null

// .............. Hidden items .............. //

func isValidHI(source)
  var result = false

  ?!source
    log.logError(_FILE, "isValidHI",
    ^"source was null")
  :?Type(source) ! "string"
    log.logError(_FILE, "isValidHI",
    ^"invalid <source> datatype." +
    ^"Expected 'string', received: '" +
    ^Type(source) + "'")
  :
    for hiddenItem : hiddenItems
      ?[hiddenItem[_HI_ID],
      ^hiddenItem[_HI_NAME]].Contains(source)
        result = true
        break

  return result

func HItoID(_name)
  var result = null

  ?isValidHI(_name)
    for hiddenItem : hiddenItems
      ?hiddenItem[_HI_NAME] = _name
        result = hiddenItem[_HI_ID]
        break

  return result
func HItoName(_id)
  var result = null

  ?isValidHI(_id)
    for hiddenItem : hiddenItems
      ?hiddenItem[_HI_ID] = _id
        result = hiddenItem[_HI_NAME]
        break

  return result

/* Returns a hidden item's required armor stat
from its ID or name,
null if there was an error. */
func getHIArmor(_key)
  var result = null

  ?isValidHI(_key)
    for hiddenItem : hiddenItems
      ?[hiddenItem[_HI_ID],
      ^hiddenItem[_HI_NAME]].Contains(_key)
        result = hiddenItem[_HI_ARMOR]
        break

  return result

// ................. Summons ................ //

func isValidTalisman(source)
  var result = false

  ?!source
    log.logError(_FILE, "isValidTalisman",
    ^"source was null")
  :?Type(source) ! "string"
    log.logError(_FILE, "isValidTalisman",
    ^"invalid <source> datatype." +
    ^"Expected 'string', received: '" +
    ^Type(source) + "'")
  :
    result = talismans.Contains(source)

  return result
func isValidSummon(source)
  var result = false

  ?!source
    log.logError(_FILE, "isValidSummon",
    ^"source was null")
  :?Type(source) ! "string"
    log.logError(_FILE, "isValidSummon",
    ^"invalid <source> datatype." +
    ^"Expected 'string', received: '" +
    ^Type(source) + "'")
  :
    result = summons.Contains(source)

  return result

/* Returns a talisman's name/ID from a summon's
ID or null if there was an error. */
func getTalisman(source)
  // entry validation
  ?!isValidSummon(source)
    return null
  :
    return talismans[summons.IndexOf(source)]
/* Returns a summon's name/ID from a talisman's
ID or null if there was an error. */
func getSummon(source)
  // entry validation
  ?!isValidSummon(source)
    return null
  :
    return summons[talismans.IndexOf(source)]

// ................. Ranges ................. //

/* Returns each item's range, or null
if there was an error.

Accounts for the Grasping Staff's
buff and Pallas's debuff.
*************************************
   REQUIRES ITEM ID EXCLUSIVELY.
************************************* */
func getRange(source)
  var result = null
  var isIncreased = false
  var canIncrease = true
  var isReduced = false

  var rangeI = ranges.IndexOf(source) +
  ^            ranges.IndexOf("RANGE")

  ?rangeI >= 3 // first range value's index
    result = ranges[rangeI]

    ?source = "crossbow" |
    ^source = "triskelion"
      canIncrease = false

    ?buffs.string = "buff_range" &
    ^canIncrease & !isIncreased
      result = result + grasping_buff
      isIncreased = true

    ?debuffs.string = "pallas_phase2_debuff" & !isReduced
      result--
      isReduced = true

    ?result >= grasping_cap & isIncreased
      result = grasping_cap
  :
    log.logError(_FILE,"getRange",
    ^"unknown <source>:\n\n" + source)
    result = null

  return result
func inRange(source)
  ?["dash","bash"].Contains(source)
    return foe.distance =
    ^math.Clamp(foe.distance,
    ^           getRange("dash_min"),
    ^           getRange("dash_max") )
  :
    return foe.distance <= getRange(source) + 1
/* TODO: interface:
Returns true if */
func betweenRange(source1, source2)
  ?!ranges.Contains(source1) |
  ^!ranges.Contains(source2)
    log.logError(_FILE,"betweenRange",
    ^"unknown <source1> or <source2>:\n\n<"+
    ^source1+">, <"+source2+">")

    return false
  :
    var range1 = getRange(source1) + 1
    var range2 = getRange(source2) + 1

    ?range1 < range2
      return foe.distance =
      ^math.Clamp(foe.distance,range1,range2)
    : // range1 >= range2
      return foe.distance =
      ^math.Clamp(foe.distance,range2,range1)

// ............. Hitbox + Splash ............ //

/* Returns an item's hitbox + splash range,
or null if there was an error.

Parameters:
  - source: item id (see map_hs for reference).
  - hand: in which the item is equipped
          (for single-wielded items only).

Value returned can vary based on:
  - item
  - attack type (melee/ranged,
    splash vs single target)
  - hand equipped (if single-wielded). */
func getHbxSplash(source, hand)
  var result = null

  ?Type(hand) ! "string"
    log.logError(_FILE, "getHbxSplash",
    ^"invalid <hand> type. Expected 'string'," +
    ^"received: " + Type(hand))
  :?!["l", "left", "r", "right"].Contains(hand)
    log.logError(_FILE, "getHbxSplash",
    ^"unknown <hand> value: " + hand)
  :
    // get source id
    for hs : map_hs
      ?hs[_HS_IDS] = source
        // add hitbox and splash areas
        result = hs[_HS_HITBOX] + hs[_HS_SPLASH]

        // add distance to foe if it's ranged
        ?hs[_HS_RANGED] & hs[_HS_IDS] ! "fissure"
          result += foe.distance

        // add 1 to hitbox if hand is right
        ?["r", "right"].Contains(hand)
          result ++

        // add grasping_buff if active
        ?buffs.string = "buff_range"
          result = result + grasping_buff

        // exit loop and return from func
        break

  return result

/* advanced version of getHitboxSplash;
analyzes currently equipped items and returns
their hitbox + splash ranges, if they're found. */
func getHbxSplash_Smart()
  // TODO: implement.
  >c0,0,#red,unimplemented.

func inHbxSplash(isSmart, source)
  // TODO: implement.
  >c0,0,#red,unimplemented.

/* Returns amount of trailing foes in a group.
This works by calculating the difference between
foes in 2 different hitbox + splash ranges.

Pre-Conditions:
- source2 can be null
- isSmart = [true, false]

Variables:
  - isSmart:
    - false: source1 and source2 will be treated
             as manual input.
    - true: automatic input, source1 and source2
             will be internally managed.
  - source1: 1st item to get range from.
  - source2: 2nd item to get range from.
             If set to null, the function will
             use foe.count (d = 46). */
func getTailFoes(isSmart, source1, source2)
  // TODO: implement.
  >c0,0,#red,unimplemented.

// ................. Damage ................. //

// TODO: COMPLETE THIS FUNCTION
/* Calculates the damage the player will deal
in their next hit.

Accounts for these external factors:
  - Lucky potion.
  - Strength potion.
  - Berserker Staff's damage increment.
  - Weaken debuffs dealt to the player.
  - If the item is a hammer and the foe has armor.

itemDmg = the base damage of your target item (> 0).
itemMult = the item's critical damage multiplier (> 0)
           (only taken into account when using Lucky potion).
_berserkerLvl = your Berserker Staff's enchantment level
             (1 <= x <= 21).
armorMult = if the target item is a hammer, its bonus
            damage multiplier to foes with armor (> 0). */
/* func getPlayerDmg()
  var result = null
  var applied = [false,false,false,false]

  ?itemDmg > 0 & itemMult > 0 &
  ^1 <= _berserkerLvl & _berserkerLvl <= 21
    ?!result
      result = itemDmg

    ?buffs.string
      ?buffs.string = "buff_staff_berserk" & !applied[0]
        result += getHiddenStat("berserk staff", _berserkerLvl)
        applied[0] = true

      ?buffs.string = "!" & !applied[1] // lucky crit buff
        ?buffs.string = "✖" & !applied[2] // lucky_mult buff
          itemMult += // whatever lucky_mult is
        result *= itemMult
        applied[1] = true
  :
    log.logError(_FILE,"getPlayerDmg",
    ^"invalid entry/entries:\n\n" + source)

    result = null
  
  return result*/

/* Calculates a foe's damage.

Accounts for damage-reduction debuffs applied,
or other external factors.
Returns null if there was an error.

_plagueLvl = if used, your Plague Wand's
            enchantment level (1 <= x <= 21).
_berserkerLvl = your Berserker Staff's enchantment
             level (1 <= x <= 21).
***************** WARNING *****************
  Since these are variable, they can't be
  calculated, so they have to be provided
        for this function to work.
******************************************* */
func getFoeDmg()
  ?(buffs.string = "buff_frozen") // Eternity Staff will prevent any damage
    return 0

  :?_berserkerLvl = math.Clamp(_berserkerLvl, 1, 21) &
  ^ _plagueLvl    = math.Clamp(_plagueLvl, 1, 21) &
  ^ _maskLvl      = math.Clamp(_maskLvl, 5, 10)

    var result = foe.damage
    // TO DO: get way to identify Plague Wand debuff
    var applied = [false,false,false,false]

    ?foe.debuffs.string
      ?buffs.string = "buff_staff_berserk" & !applied[0]
        result += (foe.damage *
        ^          (getHiddenStat("berserker staff", _berserkerLvl)
        ^           / 100))
        applied[0] = true

      ?foe.debuffs.string = "debuff_damage" & !applied[1]
        result -= 4
        applied[1] = true

      ?foe.debuffs.string = "debuff_damage" &
      ^item.GetCooldown("wand_poison") >= ((30 * u.sec) - (3 * u.sec)) & // (total cd duration) - (effect duration)
      ^!applied[2]
        result -= getHiddenStat("plague wand", _plagueLvl)
        applied[2] = true

      ?foe.debuffs.string = "feeble" & !applied[3]
        result -= (2 * (_maskLvl - 4))
        applied[3] = true

    ?result < 0
      result = 0

    return result
  
  : // invalid entries
    log.logError(_FILE,"getFoeDmg",
    ^"_invalid entry/entries:\n\n" +
    ^"_plagueLvl = " + _plagueLvl +
    ^"\n_berserkerLvl = " + _berserkerLvl)

    return null

/* Calculates the damage the Bardiche's ability will do,
based on its base damage and crit multiplier. */
func bardicheDmgR(dmg, mult)
  return (dmg + 17) * mult

// ................. Others ................. //

// TODO: COMPLETE MISSING
/* Returns stats for hidden wands or staves,
based on their enchant level. */
func getHiddenStat(hiddenName, lvl)
  // Entry sanitization
  hiddenName = string.ToLower(hiddenName)
  ?isValidHI(hiddenName) // valid hiddenName
    ?math.Clamp(lvl, 1, 21) = lvl // lvl is in range
      ?hiddenName = "berserker staff"
        return berserker_base + lvl - 1
      :?hiddenName = "plague wand"
        return plague_table[lvl - 1]
      :?hiddenName = "reset wand"
        return reset_base - (0.5 * (lvl - 1))
    :
      log.logError(_FILE,"getHiddenStat",
      ^"invalid <lvl>:\n\n" + lvl)

      return null
  :
    log.logError(_FILE,"getHiddenStat",
    ^"unknown <hiddenName>:\n\n" + hiddenName)

    return null

//  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓  //
//  ┃ ▄▀▄▀▄▀▄▀▄▀ END OF "Stats" ▄▀▄▀▄▀▄▀▄▀ ┃  //
//  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  //
