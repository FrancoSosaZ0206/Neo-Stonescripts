// imports

var log = import My/Lib/Error_Logging/public

// variables:

var _FILE = "Effect_Stats/private"

// property indexes/accessors
var _NAME = 0
var _ID = 1
var _AFFIX = 2
var _MAX_STACKS = 3

// [NAME    , ID            , AFFIX, MAX_STACKS ]
var table_debuffs = [
^["Weaken"  , "debuff_damage", "dP",      1     ],
^["Chill"   , "debuff_chill" , "dI",      6     ],
^["Burn"    , "debuff_dot"   , "dF",      1     ],
^["Stun"    , "stun"         , null,      1     ]
^]

// functions:

// data validation

func isValidId(_id)
  ?Type(_id) = "string"
    for debuff : table_debuffs
      ?_id = debuff[_ID]
        return true
  
  return false
func isValidName(_name)
  ?Type(_name) = "string"
    for debuff : table_debuffs
      ?_name = debuff[_NAME]
        return true
  
  return false
func isValidAffix(_affix)
  ?Type(_affix) = "string"
    for debuff : table_debuffs
      ?_affix = debuff[_AFFIX]
        return true
  
  return false

// list generators

func listIds()
  var idArr = []

  for debuff : table_debuffs
    idArr.Add(debuff[_ID])

  return idArr
func listNames()
  var nameArr = []

  for debuff : table_debuffs
    nameArr.Add(debuff[_NAME])

  return nameArr
func listAffixes()
  var affixArr = []

  for debuff : table_debuffs
    affixArr.Add(debuff[_AFFIX])

  return affixArr

// transformers

// Can recieve a name or an affix (if it has one).
func toId(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_AFFIX]].Contains(_key)
      return debuff[_ID]

  return null

// Can recieve an id or an affix (if it has one).
func toName(_key)
  for debuff : table_debuffs
    ?[debuff[_ID], debuff[_AFFIX]].Contains(_key)
      return debuff[_NAME]

  return null

/* Returns debuff's affix if it has one, null otherwise.
Can recieve a debuff name or id. */
func toAffix(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_AFFIX]

  return null
func toMaxStacks(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_MAX_STACKS]

  return null

// miscellaneous

func isDebuffable()
  return !(foe.buffs.string = "buff_tenacious" |
  ^        foe.buffs.string = "buff_protection" )
func isImmuneTo(_id)
  var result = false
  ?Type(_id) ! "string"
    log.logError(_FILE, "isImmuneTo",
    ^"invalid <_id> type: expected 'string', recieved '"+Type(_id)+"'")

  :?!isValidId(_id)
    log.logError(_FILE, "isImmuneTo",
    ^"unknown <_id>: "+_id)
  :
    result = (foe = "immune_to_"+_id)

  return result
func canDebuff(_id)
  var result = false

  // entry sanitization
  ?Type(_id) ! "string"
    log.logError(_FILE, "canDebuff",
    ^"invalid <_id> type: expected 'string', recieved '"+Type(_id)+"'")

  :?!isValidId(_id)
    log.logError(_FILE, "canDebuff",
    ^"unknown <_id>: "+_id)
  :
    result = (isDebuffable() & !(isImmuneTo(_id) |
    ^         foe.debuffs.string = _id+":"+toMaxStacks(_id)))

  return result

// mode (string) values: "any", "all"
func canMultiDebuff(_idArr, mode)
  var result = false
  // entry sanitization
  ?Type(_idArr) ! "array"
    log.logError(_FILE, "canDebuff",
    ^"invalid <_id> type: expected 'array', recieved '"+Type(_idArr)+"'")
  :?Type(mode) ! "string"
    log.logError(_FILE, "canDebuff",
    ^"invalid <mode> type: expected 'string', recieved '"+Type(mode)+"'")
  
  // entry validation
  :?!["any", "all"].Contains(string.ToLower(mode))
    log.logError(_FILE, "canDebuff",
    ^"unknown <mode> value: "+mode)
  :
    var validIdArr = true
    var invalidId = null

    for _id : _idArr
      ?!isValidId(_id)
        validIdArr = false
        invalidId = _id
        break

    ?!validIdArr
      log.logError(_FILE, "canDebuff",
      ^"<_idArr> has 1 or more invalid elements: "+invalidId)

    : // procedure
      result = isDebuffable()

      ?result
        var aux
        for _id : _idArr
          ?mode = "any"
            aux = (aux | canDebuff(_id))
          : // mode = "all"
            aux = (aux & canDebuff(_id))

        result = (result & aux)

  return result

func canUnmake()
  return !(foe = "boss" | foe = "monarch")
