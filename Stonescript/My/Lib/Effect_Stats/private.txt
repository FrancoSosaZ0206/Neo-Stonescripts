// imports

var log = import My/Lib/Error_Logging/public

// variables:

var _FILE = "Effect_Stats/private"

// property indexes/accessors
var _NAME = 0
var _ID = 1
var _AFFIX = 2
var _MAX_STACKS = 3

// [NAME    , ID            , AFFIX, MAX_STACKS ]
var table_debuffs = [
^["Weaken"  , "debuff_damage", "dP",      1     ],
^["Chill"   , "debuff_chill" , "dI",      6     ],
^["Burn"    , "debuff_dot"   , "dF",      1     ],
^["Stun"    , "stun"         , null,      1     ]
^]

// functions:

// data validation

func isValidId(_id)
  ?Type(_id) = "string"
    for debuff : table_debuffs
      ?_id = debuff[_ID]
        return true
  
  return false
func isValidName(_name)
  ?Type(_name) = "string"
    for debuff : table_debuffs
      ?_name = debuff[_NAME]
        return true
  
  return false
func isValidAffix(_affix)
  ?Type(_affix) = "string"
    for debuff : table_debuffs
      ?_affix = debuff[_AFFIX]
        return true
  
  return false

func getType(_key)
  var result = null

  ?Type(_key) = "string"
    ?isValidId(_key)
      result = "ID"
    :?isValidName(_key)
      result = "NAME"
  :
    return result

// list generators

func listIds()
  var idArr = []

  for debuff : table_debuffs
    idArr.Add(debuff[_ID])

  return idArr
func listNames()
  var nameArr = []

  for debuff : table_debuffs
    nameArr.Add(debuff[_NAME])

  return nameArr
func listAffixes()
  var affixArr = []

  for debuff : table_debuffs
    affixArr.Add(debuff[_AFFIX])

  return affixArr

// transformers

// Can recieve a name or an affix (if it has one).
func toId(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_AFFIX]].Contains(_key)
      return debuff[_ID]

  return null

// Can recieve an id or an affix (if it has one).
func toName(_key)
  for debuff : table_debuffs
    ?[debuff[_ID], debuff[_AFFIX]].Contains(_key)
      return debuff[_NAME]

  return null

/* Returns debuff's affix if it has one, null otherwise.
Can recieve a debuff name or id. */
func toAffix(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_AFFIX]

  return null
func toMaxStacks(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_MAX_STACKS]

  return null

// miscellaneous

func isDebuffable()
  return !(foe.buffs.string = "buff_tenacious" |
  ^        foe.buffs.string = "buff_protection" )
func isImmuneTo(_key)
  var result = false
  var keyType = getType(_key)

  ?!["ID", "NAME"].Contains(keyType)
    log.logError(_FILE, "isImmuneTo",
    ^            "invalid <_key>: "+_key)

  :
    ?keyType = "NAME"
      _key = toId(_key)
    
    result = (foe = "immune_to_"+_key)

  return result
func canDebuff(_key)
  var result = false
  var keyType = getType(_key)

  ?!["ID", "NAME"].Contains(keyType)
    log.logError(_FILE, "canDebuff",
    ^            "invalid <_key>: "+_key)

  :
    ?keyType = "NAME"
      _key = toId(_key)

    result =
    ^   (isDebuffable() &
    ^    !(isImmuneTo(_key) |
    ^      foe.debuffs.string =
    ^        _key+":"+toMaxStacks(_key)))

  return result

// mode (string) values: "any", "all"
func canMultiDebuff(_keyArr, mode)
  var result = false

  // entry sanitization
  ?Type(_keyArr) ! "array"
    log.logError(_FILE, "canDebuff",
    ^  "invalid <_id> type: expected 'array'"+
    ^  ", recieved '"+Type(_keyArr)+"'")
  :?Type(mode) ! "string"
    log.logError(_FILE, "canDebuff",
    ^  "invalid <mode> type: expected 'string'"+
    ^  ", recieved '"+Type(mode)+"'")
  
  // entry validation
  :?!["any", "all"].Contains(string.ToLower(mode))
    log.logError(_FILE, "canDebuff",
    ^  "unknown <mode> value: "+mode)
  :
    var validKeyArr = true
    var invalidKey = null

    for _key : _keyArr
      ?!["ID", "NAME"].Contains(getType(_key))
        validKeyArr = false
        invalidKey = _key
        break

    ?!validKeyArr
      log.logError(_FILE, "canDebuff",
      ^  "<_keyArr> has 1 or more invalid"+
      ^  " elements: "+invalidKey)

    : // procedure
      result = isDebuffable()

      ?result
        var aux
        for _key : _keyArr
          ?getType(_key) = "NAME"
            _key = toId(_key)

          ?mode = "any"
            aux = (aux | canDebuff(_key))
          : // mode = "all"
            aux = (aux & canDebuff(_key))

        result = (result & aux)

  return result

func canUnmake()
  return !(foe = "boss" | foe = "monarch")
