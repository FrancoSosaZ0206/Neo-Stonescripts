// variables:

// property indexes/accessors
var _NAME = 0
var _ID = 1
var _AFFIX = 2
var _MAX_STACKS = 3

// [NAME    , ID            , AFFIX, MAX_STACKS]
var table_debuffs = [
^["Weaken"  , "debuff_damage", "dP", 1],
^["Chill"   , "debuff_chill" , "dI", 6],
^["Burn"    , "debuff_dot"   , "dF", 1],
^["Stun"    , "stun"         , null, 1]
^]

// functions:

// data validation

func isValidId(_id)
  ?Type() = "string"
    for debuff : table_debuffs
      ?_id = table_debuffs[_ID]
        return true
  
  return false
func isValidName(_name)
  ?Type() = "string"
    for debuff : table_debuffs
      ?_name = table_debuffs[_NAME]
        return true
  
  return false
func isValidAffix(_affix)
  ?Type() = "string"
    for debuff : table_debuffs
      ?_affix = table_debuffs[_AFFIX]
        return true
  
  return false

// list getters

func getIds()
  var idArr = []

  for debuff : table_debuffs
    idArr.Add(debuff[_ID])

  return idArr
func getNames()
  var nameArr = []

  for debuff : table_debuffs
    nameArr.Add(debuff[_NAME])

  return nameArr
func getAffixes()
  var affixArr = []

  for debuff : table_debuffs
    affixArr.Add(debuff[_AFFIX])

  return affixArr

// transformers

func toId(_name)
  for debuff : table_debuffs
    ?_name = debuff[_NAME]
      return debuff[_ID]

  return null
func toName(_id)
  for debuff : table_debuffs
    ?_id = debuff[_id]
      return debuff[_NAME]

  return null

// data getters

/* Returns debuff's affix if it has one, null otherwise.
Can recieve a debuff name or id. */
func getAffix(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_AFFIX]

  return null
func getMaxStacks(_key)
  for debuff : table_debuffs
    ?[debuff[_NAME], debuff[_ID]].Contains(_key)
      return debuff[_MAX_STACKS]

  return null

// miscellaneous

func isDebuffable()
  return !(foe.buffs.string = "buff_tenacious" |
  ^        foe.buffs.string = "buff_protection" )
func canDebuff(_id)
  // entry sanitization
  ?Type(_id) ! "string"
    >c0,0,#ff0000,ERROR\nFILE: Debuff_Stats/private\nAT: canDebuff\nCAUSE: invalid <_id> type: expected "string", recieved "@Type(_id)@".
    return false

  :?!isValidId(_id)
    >c0,0,#ff0000,ERROR\nFILE: Debuff_Stats/private\nAT: canDebuff\nCAUSE: unknown <_id>: @_id@
    return false
  :
    return isDebuffable() &
    ^      !(foe.debuffs.string = _id+":"+getMaxStacks(_id) |
    ^        foe = "immnue_to_"+_id)

// mode (string) values: "any", "all"
func canMultiDebuff(_idArr, mode)
  // entry sanitization
  ?Type(_idArr) ! "array"
    >c0,0,#ff0000,ERROR\n
    ^FILE: Debuff_Stats/private\n
    ^AT: canDebuff\n
    ^CAUSE: invalid <_id> type: expected "array", recieved "@Type(_idArr)@".
    return false
  :?Type(mode) ! "string"
    >c0,0,#ff0000,ERROR\n
    ^FILE: Debuff_Stats/private\n
    ^AT: canDebuff\n
    ^CAUSE: invalid <mode> type: expected "string", recieved "@Type(mode)@".
    return false
  
  // entry validation
  :?!["any", "all"].Contains(string.ToLower(mode))
    >c0,0,#ff0000,ERROR\n
    ^FILE: Debuff_Stats/private\n
    ^AT: canDebuff\n
    ^CAUSE: unknown <mode> value: @mode@.
    return false
  :
    var validIdArr = true
    var invalidId = null
    for _id : _idArr
      ?!isValidId(_id)
        validIdArr = false
        invalidId = _id
        break

    ?!validIdArr
      >c0,0,#ff0000,ERROR\n
      ^FILE: Debuff_Stats/private\n
      ^AT: canDebuff\n
      ^CAUSE: <_idArr> has 1 or more invalid elements: @invalidId@
      return false

    : // procedure
      var result = isDebuffable()

      ?result
        var aux
        for _id : _idArr
          ?mode = "any"
            aux = (aux | canDebuff(_id))
          : // mode = "all"
            aux = (aux & canDebuff(_id))

        result = (result & aux)
      
      return result

func canUnmake()
  return !(foe = "boss" | foe = "monarch")
